{
  "fc6b2c11d8ef528a4a2b554b0fe7071b6959f9fe:types/xald-parse-sdk/package.json": "{\n    \"private\": true,\n    \"types\": \"index\",\n    \"typesVersions\": {\n        \"<=3.6\": {\n            \"*\": [\n                \"ts3.6/*\"\n            ]\n        }\n    }\n}\n",
  "fc6b2c11d8ef528a4a2b554b0fe7071b6959f9fe:types/xald-parse-sdk/ts3.6/tsconfig.json": "{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"lib\": [\n            \"es6\",\n            \"dom\"\n        ],\n        \"noImplicitAny\": true,\n        \"noImplicitThis\": true,\n        \"strictNullChecks\": true,\n        \"strictFunctionTypes\": true,\n        \"baseUrl\": \"../../\",\n        \"typeRoots\": [\n            \"../../\"\n        ],\n        \"types\": [],\n        \"noEmit\": true,\n        \"forceConsistentCasingInFileNames\": true\n    },\n    \"files\": [\n        \"index.d.ts\",\n        \"xald-parse-sdk-tests.ts\"\n    ]\n}\n",
  "fc6b2c11d8ef528a4a2b554b0fe7071b6959f9fe:types/xald-parse-sdk/ts3.6/tslint.json": "{\n    \"extends\": \"@definitelytyped/dtslint/dt.json\",\n    \"rules\": {\n        \"ban-types\": false,\n        \"no-unnecessary-generics\": false\n    }\n}\n",
  "fc6b2c11d8ef528a4a2b554b0fe7071b6959f9fe:types/xald-parse-sdk/tsconfig.json": "{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"lib\": [\n            \"es6\",\n            \"dom\"\n        ],\n        \"noImplicitAny\": true,\n        \"noImplicitThis\": true,\n        \"strictFunctionTypes\": true,\n        \"strictNullChecks\": true,\n        \"baseUrl\": \"../\",\n        \"typeRoots\": [\n            \"../\"\n        ],\n        \"types\": [],\n        \"noEmit\": true,\n        \"forceConsistentCasingInFileNames\": true\n    },\n    \"files\": [\n        \"index.d.ts\",\n        \"xald-parse-sdk-tests.ts\"\n    ]\n}\n",
  "fc6b2c11d8ef528a4a2b554b0fe7071b6959f9fe:types/xald-parse-sdk/tslint.json": "{\n    \"extends\": \"@definitelytyped/dtslint/dt.json\",\n    \"rules\": {\n        \"ban-types\": false,\n        \"no-unnecessary-generics\": false\n    }\n}",
  "fc6b2c11d8ef528a4a2b554b0fe7071b6959f9fe:types/xald-parse-sdk/index.d.ts": "// Type definitions for xald-parse-sdk 1.0\n// Project: https://parseplatform.org/\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// Minimum TypeScript Version: 3.5\n\n/// <reference types=\"node\" />\n/// <reference path=\"taobao.d.ts\" />\n\nimport { EventEmitter } from \"events\";\n\ndeclare enum ErrorCode {\n    OTHER_CAUSE = -1,\n    INTERNAL_SERVER_ERROR = 1,\n    CONNECTION_FAILED = 100,\n    OBJECT_NOT_FOUND = 101,\n    INVALID_QUERY = 102,\n    INVALID_CLASS_NAME = 103,\n    MISSING_OBJECT_ID = 104,\n    INVALID_KEY_NAME = 105,\n    INVALID_POINTER = 106,\n    INVALID_JSON = 107,\n    COMMAND_UNAVAILABLE = 108,\n    NOT_INITIALIZED = 109,\n    INCORRECT_TYPE = 111,\n    INVALID_CHANNEL_NAME = 112,\n    PUSH_MISCONFIGURED = 115,\n    OBJECT_TOO_LARGE = 116,\n    OPERATION_FORBIDDEN = 119,\n    CACHE_MISS = 120,\n    INVALID_NESTED_KEY = 121,\n    INVALID_FILE_NAME = 122,\n    INVALID_ACL = 123,\n    TIMEOUT = 124,\n    INVALID_EMAIL_ADDRESS = 125,\n    MISSING_CONTENT_TYPE = 126,\n    MISSING_CONTENT_LENGTH = 127,\n    INVALID_CONTENT_LENGTH = 128,\n    FILE_TOO_LARGE = 129,\n    FILE_SAVE_ERROR = 130,\n    DUPLICATE_VALUE = 137,\n    INVALID_ROLE_NAME = 139,\n    EXCEEDED_QUOTA = 140,\n    SCRIPT_FAILED = 141,\n    VALIDATION_ERROR = 142,\n    INVALID_IMAGE_DATA = 150,\n    UNSAVED_FILE_ERROR = 151,\n    INVALID_PUSH_TIME_ERROR = 152,\n    FILE_DELETE_ERROR = 153,\n    REQUEST_LIMIT_EXCEEDED = 155,\n    INVALID_EVENT_NAME = 160,\n    USERNAME_MISSING = 200,\n    PASSWORD_MISSING = 201,\n    USERNAME_TAKEN = 202,\n    EMAIL_TAKEN = 203,\n    EMAIL_MISSING = 204,\n    EMAIL_NOT_FOUND = 205,\n    SESSION_MISSING = 206,\n    MUST_CREATE_USER_THROUGH_SIGNUP = 207,\n    ACCOUNT_ALREADY_LINKED = 208,\n    INVALID_SESSION_TOKEN = 209,\n    LINKED_ID_MISSING = 250,\n    INVALID_LINKED_SESSION = 251,\n    UNSUPPORTED_SERVICE = 252,\n    AGGREGATE_ERROR = 600,\n    FILE_READ_ERROR = 601,\n    X_DOMAIN_REQUEST = 602,\n}\n\ndeclare global {\n    namespace Parse {\n        let applicationId: string;\n        let javaScriptKey: string | undefined;\n        let liveQueryServerURL: string;\n        let masterKey: string | undefined;\n        let serverAuthToken: string | undefined;\n        let serverAuthType: string | undefined;\n        let serverURL: string;\n        let secret: string;\n        let idempotency: boolean;\n        let encryptedUser: boolean;\n        let env: string;\n        let cloudAppId: string;\n        let cloudTimeOut: string;\n\n        interface BatchSizeOption {\n            batchSize?: number | undefined;\n        }\n\n        interface CascadeSaveOption {\n            /** If `false`, nested objects will not be saved (default is `true`). */\n            cascadeSave?: boolean | undefined;\n        }\n\n        interface SuccessOption {\n            success?: Function | undefined;\n        }\n\n        interface ErrorOption {\n            error?: Function | undefined;\n        }\n\n        interface ContextOption {\n            context?: {[key: string]: any};\n        }\n\n        interface FullOptions {\n            success?: Function | undefined;\n            error?: Function | undefined;\n            useMasterKey?: boolean | undefined;\n            sessionToken?: string | undefined;\n            installationId?: string | undefined;\n            progress?: Function | undefined;\n        }\n\n        interface RequestOptions {\n            useMasterKey?: boolean | undefined;\n            sessionToken?: string | undefined;\n            installationId?: string | undefined;\n            batchSize?: number | undefined;\n            include?: string | string[] | undefined;\n            progress?: Function | undefined;\n        }\n\n        interface SuccessFailureOptions extends SuccessOption, ErrorOption {}\n\n        interface SignUpOptions {\n            useMasterKey?: boolean | undefined;\n            installationId?: string | undefined;\n        }\n\n        interface SessionTokenOption {\n            sessionToken?: string | undefined;\n        }\n\n        interface WaitOption {\n            /**\n             * Set to true to wait for the server to confirm success\n             * before triggering an event.\n             */\n            wait?: boolean | undefined;\n        }\n\n        interface UseMasterKeyOption {\n            /**\n             * In Cloud Code and Node only, causes the Master Key to be used for this request.\n             */\n            useMasterKey?: boolean | undefined;\n        }\n\n        interface ScopeOptions extends SessionTokenOption, UseMasterKeyOption {}\n\n        interface SilentOption {\n            /**\n             * Set to true to avoid firing the event.\n             */\n            silent?: boolean | undefined;\n        }\n\n        interface Pointer {\n            __type: string;\n            className: string;\n            objectId: string;\n        }\n\n        interface AuthData {\n            [key: string]: any;\n        }\n\n        /**\n         * Interface declaration for Authentication Providers\n         * https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html\n         */\n        interface AuthProvider {\n            /**\n             * Called when _linkWith isn't passed authData. Handle your own authentication here.\n             */\n            authenticate: () => void;\n            /**\n             * (Optional) Called when service is unlinked. Handle any cleanup here.\n             */\n            deauthenticate?: (() => void) | undefined;\n            /**\n             * Unique identifier for this Auth Provider.\n             */\n            getAuthType: () => string;\n            /**\n             * Called when auth data is syncronized. Can be used to determine if authData is still valid\n             */\n            restoreAuthentication: () => boolean;\n        }\n\n        interface BaseAttributes {\n            createdAt: Date;\n            objectId: string;\n            updatedAt: Date;\n        }\n\n        interface CommonAttributes {\n            ACL: ACL;\n        }\n\n        interface JSONBaseAttributes {\n            createdAt: string;\n            objectId: string;\n            updatedAt: string;\n        }\n\n        /**\n         * Creates a new ACL.\n         * If no argument is given, the ACL has no permissions for anyone.\n         * If the argument is a Parse.User, the ACL will have read and write\n         *   permission for only that user.\n         * If the argument is any other JSON object, that object will be interpretted\n         *   as a serialized ACL created with toJSON().\n         * @see Parse.Object#setACL\n         *\n         * <p>An ACL, or Access Control List can be added to any\n         * <code>Parse.Object</code> to restrict access to only a subset of users\n         * of your application.</p>\n         */\n        class ACL {\n            permissionsById: any;\n\n            constructor(arg1?: any);\n\n            setPublicReadAccess(allowed: boolean): void;\n            getPublicReadAccess(): boolean;\n\n            setPublicWriteAccess(allowed: boolean): void;\n            getPublicWriteAccess(): boolean;\n\n            setReadAccess(userId: User | string, allowed: boolean): void;\n            getReadAccess(userId: User | string): boolean;\n\n            setWriteAccess(userId: User | string, allowed: boolean): void;\n            getWriteAccess(userId: User | string): boolean;\n\n            setRoleReadAccess(role: Role | string, allowed: boolean): void;\n            getRoleReadAccess(role: Role | string): boolean;\n\n            setRoleWriteAccess(role: Role | string, allowed: boolean): void;\n            getRoleWriteAccess(role: Role | string): boolean;\n\n            toJSON(): any;\n        }\n\n        /**\n         * A Parse.File is a local representation of a file that is saved to the Parse\n         * cloud.\n         * @param name The file's name. This will be prefixed by a unique\n         *     value once the file has finished saving. The file name must begin with\n         *     an alphanumeric character, and consist of alphanumeric characters,\n         *     periods, spaces, underscores, or dashes.\n         * @param data The data for the file, as either:\n         *     1. an Array of byte value Numbers, or\n         *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n         *     3. a File object selected with a file upload control. (3) only works\n         *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n         *        For example:<pre>\n         * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n         * if (fileUploadControl.files.length > 0) {\n         *   var file = fileUploadControl.files[0];\n         *   var name = \"photo.jpg\";\n         *   var parseFile = new Parse.File(name, file);\n         *   parseFile.save().then(function() {\n         *     // The file has been saved to Parse.\n         *   }, function(error) {\n         *     // The file either could not be read, or could not be saved to Parse.\n         *   });\n         * }</pre>\n         * @param type Optional Content-Type header to use for the file. If\n         *     this is omitted, the content type will be inferred from the name's\n         *     extension.\n         */\n        class File {\n            constructor(\n                name: string,\n                data: number[] | { base64: string } | { size: number; type: string } | { uri: string },\n                type?: string,\n            );\n            /**\n             * Return the data for the file, downloading it if not already present.\n             * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n             * Data is cleared if saved with File object selected with a file upload control\n             *\n             * @returns Promise that is resolved with base64 data\n             */\n            getData(): Promise<string>;\n            url(options?: { forceSecure?: boolean | undefined }): string;\n            metadata(): Record<string, any>;\n            tags(): Record<string, any>;\n            name(): string;\n            save(options?: FullOptions): Promise<File>;\n            cancel(): void;\n            destroy(): Promise<File>;\n            toJSON(): { __type: string; name: string; url: string };\n            equals(other: File): boolean;\n            setMetadata(metadata: Record<string, any>): void;\n            addMetadata(key: string, value: any)"
}
