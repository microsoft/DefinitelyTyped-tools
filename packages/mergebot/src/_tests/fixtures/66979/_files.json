{
  "7ba7b83f2147403af9578673a88aaa765cae3d76:types/react-blessed/index.d.ts": "// Type definitions for react-blessed 0.7\n// Project: https://github.com/yomguithereal/react-blessed#readme\n// Definitions by: Century Guo <https://github.com/guoshencheng>\n//                 Robbie Nichols <https://github.com/defnotrobbie>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// Minimum TypeScript Version: 4.1\n\nimport * as React from \"react\";\nimport * as Blessed from \"blessed\";\n\nexport {};\n\n/* RENDERER *****************************************************************/\n\nexport type Callback = () => void | null | undefined;\nexport type renderer = (c: JSX.Element, s: Blessed.Widgets.Screen, callback?: Callback) => React.Component | null;\nexport function render(c: JSX.Element, s: Blessed.Widgets.Screen, callback?: Callback): React.Component | null;\n\nexport function createBlessedRenderer(bls: any): renderer;\n\n/* BLESSED ELEMENTS **********************************************************/\n\nexport type Element = Blessed.Widgets.BlessedElement;\nexport type ScrollableBoxElement = Blessed.Widgets.ScrollableBoxElement;\nexport type ScrollableTextElement = Blessed.Widgets.ScrollableTextElement;\nexport type BoxElement = Blessed.Widgets.BoxElement;\nexport type TextElement = Blessed.Widgets.TextElement;\nexport type LineElement = Blessed.Widgets.LineElement;\nexport type BigTextElement = Blessed.Widgets.BigTextElement;\nexport type ListElement = Blessed.Widgets.ListElement;\nexport type FileManagerElement = Blessed.Widgets.FileManagerElement;\nexport type ListTableElement = Blessed.Widgets.ListTableElement;\nexport type ListbarElement = Blessed.Widgets.ListbarElement;\nexport type InputElement = Blessed.Widgets.InputElement;\nexport type TextareaElement = Blessed.Widgets.TextareaElement;\nexport type TextboxElement = Blessed.Widgets.TextboxElement;\nexport type ButtonElement = Blessed.Widgets.ButtonElement;\nexport type CheckboxElement = Blessed.Widgets.CheckboxElement;\nexport type RadioSetElement = Blessed.Widgets.RadioSetElement;\nexport type RadioButtonElement = Blessed.Widgets.RadioButtonElement;\nexport type TableElement = Blessed.Widgets.TableElement;\nexport type PromptElement = Blessed.Widgets.PromptElement;\nexport type QuestionElement = Blessed.Widgets.QuestionElement;\nexport type MessageElement = Blessed.Widgets.MessageElement;\nexport type LoadingElement = Blessed.Widgets.LoadingElement;\nexport type LogElement = Blessed.Widgets.Log;\nexport type ProgressBarElement = Blessed.Widgets.ProgressBarElement;\nexport type TerminalElement = Blessed.Widgets.TerminalElement;\nexport type LayoutElement = Blessed.Widgets.LayoutElement;\n\n/* EVENTS *******************************************************************/\n\ntype Prefix<T extends string, P extends string> = `${T}${P}`;\n\n// create event handlers that map to 'blessed' events. see\n// https://github.com/Yomguithereal/react-blessed/blob/f5e1f791dea1788745695d557040b91f573f9ef5/src/fiber/events.js\ntype EventHandlerProp<T extends string, E extends (...args: never) => void> = {\n    [key in `on${Capitalize<T>}`]?: E;\n};\n\n// 'react-blessed' handles 'blessed' events by matching event names to\n// handlers by prefixing event names with with \"on\" and camelCasing the\n// result. this cannot be fully recreated in TS so we must manually map them\n// here.\ntype ScreenElement = \"click\" | \"mouseover\" | \"mouseout\" | \"mouseup\";\ntype ScreenElementPrefix = \"element\";\ntype ExludedScreenEventNames = Prefix<ScreenElementPrefix, Prefix<\" \", ScreenElement>>;\ntype CamelCasedScreenEventNames = Prefix<ScreenElementPrefix, Capitalize<ScreenElement>>;\n\ntype ScreenEventNames =\n    | Exclude<Blessed.Widgets.NodeScreenEventType, ExludedScreenEventNames>\n    | CamelCasedScreenEventNames;\n\ntype GenericContentPrefix = \"set\" | \"parsed\";\ntype GenericContent = \"content\";\ntype ExludedGenericEventNames = Prefix<GenericContentPrefix, Prefix<\" \", GenericContent>>;\ntype CamelCasedGenericEventNames = Prefix<GenericContentPrefix, Capitalize<GenericContent>>;\n\ntype GenericEventNames =\n    | Exclude<Blessed.Widgets.NodeGenericEventType, ExludedGenericEventNames>\n    | CamelCasedGenericEventNames;\n\ntype ProgressBarEventNames = Parameters<Blessed.Widgets.ProgressBarElement[\"on\"]>[0];\n\ntype SpreadableArgs<T, K = T extends unknown[] ? T : [T]> = K;\n\ninterface EventHandler<T> {\n    (...args: SpreadableArgs<T>): void;\n}\n\n// event args need to be manually typed because Blessed.Widgets.NodeWithEvents\n// overloads the event handlers (making it impossible? to extract the\n// parameters with TS utils) and does not expose the event callbacks as\n// importable types\n\nexport type ScreenEvent = Blessed.Widgets.Screen;\nexport type ScreenEventHandler = EventHandler<ScreenEvent>;\ntype ScreenEventProps = EventHandlerProp<ScreenEventNames, ScreenEventHandler>;\n\nexport type MouseEvent = Blessed.Widgets.Events.IMouseEventArg;\nexport type MouseEventHandler = EventHandler<MouseEvent>;\ntype MouseEventProps = EventHandlerProp<Blessed.Widgets.NodeMouseEventType, MouseEventHandler>;\n\nexport type GenericEvent = undefined;\nexport type GenericEventHandler = EventHandler<GenericEvent>;\ntype GenericEventProps = EventHandlerProp<GenericEventNames, GenericEventHandler>;\n\nexport type KeyPressEvent = [key: any, event: Blessed.Widgets.Events.IKeyEventArg];\nexport type KeyPressEventHandler = EventHandler<KeyPressEvent>;\ntype KeyPressEventProps = EventHandlerProp<\"keypress\", KeyPressEventHandler>;\n\nexport type WarningEvent = string;\nexport type WarningEventHandler = EventHandler<WarningEvent>;\ntype WarningEventProps = EventHandlerProp<\"warning\", WarningEventHandler>;\n\nexport type ProgressBarEvent = undefined;\nexport type ProgressBarEventHandler = EventHandler<ProgressBarEvent>;\ntype ProgressBarEventProps = EventHandlerProp<ProgressBarEventNames, ProgressBarEventHandler>;\ninterface EventProps\n    extends ScreenEventProps,\n        GenericEventProps,\n        MouseEventProps,\n        KeyPressEventProps,\n        WarningEventProps {}\n\n/* BLESSED-REACT LOCALLY DEFINED PROPS **************************************/\n\n// @types/blessed defines 'styles' as 'any' but 'blessed' can only can only\n// take certain values. define them here.\n\ninterface BorderStyle {\n    type?: \"line\" | \"bg\";\n    ch?: string;\n    bg?: string;\n    fg?: string;\n    bold?: boolean;\n    underline?: boolean;\n}\ninterface ItemStyle {\n    bg?: string;\n    fg?: string;\n    bold?: boolean;\n    underline?: boolean;\n    blink?: boolean;\n    inverse?: boolean;\n    invisible?: boolean;\n}\ninterface ListStyle extends ElementStyle {\n    selected?: ItemStyle;\n    item?: ItemStyle;\n}\ninterface ProgressBarStyle extends ElementStyle {\n    bar?: { bg?: string; fg?: string };\n}\ninterface ElementStyle extends ItemStyle {\n    border?: BorderStyle;\n    focus?: { bg?: string; fg?: string };\n    hover?: { bg?: string; fg?: string };\n    transparent?: boolean;\n    scrollbar?: { bg?: string; fg?: string; track?: { bg?: string; fg?: string } };\n}\n\n// remove indexers\n// https://stackoverflow.com/questions/51465182/how-to-remove-index-signature-using-mapped-types\ntype KnownKeys<T> = {\n    [K in keyof T as string extends K ? never : number extends K ? never : K]: T[K];\n};\n\ntype WithClassProp<T, K = T | undefined | false | null> = T & { class?: K | K[] };\ntype ProgressBarProps<T> = T extends ProgressBarElement ? ProgressBarEventProps & { style?: ProgressBarStyle } : {};\ntype ListProps<T> = T extends ListElement ? ProgressBarEventProps & { style?: ListStyle; selected?: number } : {};\n// layout does not require prop 'layout' in Blessed.Widgets.LayoutOptions--make it optional\ntype LayoutProps<T> = T extends LayoutElement ? Partial<Blessed.Widgets.LayoutOptions> : {};\n\n// remove {[key: string]: any} indexer defined in Blessed.Widgets.IOptions.\n// 'blessed' doesn't exist in a DOM so it probably doesn't make sense to allow any property\ntype FilterOptions<T extends Record<any, any>> = Partial<Omit<KnownKeys<T>, \"style\" | \"children\">>;\n\ntype ModifiedBlessedOptions<T extends Record<any, any>> = FilterOptions<T> & { children?: React.ReactNode; style?: ElementStyle } & EventProps;\n\n/* REACT-BLESSED JSX ********************************************************/\n\n/**\n *\n * this type can be used to get props for 'react-blessed' elements in the same\n * manner that React.HTMLProps can be used to get DOM element props. e.g.\n * ```ts\n * import { FC } from 'react'\n * import { BlessedProps, BoxElement } from 'react-blessed';\n * type MyBoxProps = BlessedProps<BoxElement>;\n * const MyBox: React.FC<MyBoxProps> = props => <box {...props} />;\n * ```\n * @see DetailedBlessedProps\n * @see React.HTMLAttributes\n */\nexport type BlessedAttributes<E extends Element> = WithClassProp<\n    ModifiedBlessedOptions<E[\"options\"]> & ProgressBarProps<E> & ListProps<E> & LayoutProps<E>\n>;\n\n/**\n * mirrors react prop generation for HTML JSX.IntrinsicElements.\n * @see React.DetailedHTMLProps\n */\nexport type DetailedBlessedProps<E extends Element> = BlessedAttributes<E> & React.ClassAttributes<E>;\n\nexport interface BlessedIntrinsicElements {\n    element: DetailedBlessedProps<Element>;\n    box: DetailedBlessedProps<BoxElement>;\n    scrollablebox: DetailedBlessedProps<ScrollableBoxElement>;\n    scrollabletext: DetailedBlessedProps<ScrollableTextElement>;\n    bigtext: DetailedBlessedProps<BigTextElement>;\n    list: DetailedBlessedProps<ListElement>;\n    filemanager: DetailedBlessedProps<FileManagerElement>;\n    listtable: DetailedBlessedProps<ListTableElement>;\n    listbar: DetailedBlessedProps<ListbarElement>;\n    textbox: DetailedBlessedProps<TextboxElement>;\n    checkbox: DetailedBlessedProps<CheckboxElement>;\n    radioset: DetailedBlessedProps<RadioSetElement>;\n    radiobutton: DetailedBlessedProps<RadioButtonElement>;\n    prompt: DetailedBlessedProps<PromptElement>;\n    question: DetailedBlessedProps<QuestionElement>;\n    message: DetailedBlessedProps<MessageElement>;\n    loading: DetailedBlessedProps<LoadingElement>;\n    log: DetailedBlessedProps<LogElement>;\n    progressbar: DetailedBlessedProps<ProgressBarElement>;\n    terminal: DetailedBlessedProps<Blessed.Widgets.TerminalElement>;\n    layout: DetailedBlessedProps<Blessed.Widgets.LayoutElement>;\n    // escape: Blessed.escape is not an element\n    // program: Blessed.Widgets.Program is not an element\n}\n\n// 'react-blessed' accepts JSX with 'blessed' ",
  "f11a1a009614559b5c5db1f68732927f1b8ab5f2:types/react-blessed/index.d.ts": "// Type definitions for react-blessed 0.7\n// Project: https://github.com/yomguithereal/react-blessed#readme\n// Definitions by: Century Guo <https://github.com/guoshencheng>\n//                 Robbie Nichols <https://github.com/defnotrobbie>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// Minimum TypeScript Version: 4.1\n\nimport * as Blessed from \"blessed\";\nimport * as React from \"react\";\n\nexport {};\n\n/* RENDERER *****************************************************************/\n\nexport type Callback = () => void | null | undefined;\nexport type renderer = (c: JSX.Element, s: Blessed.Widgets.Screen, callback?: Callback) => React.Component | null;\nexport function render(c: JSX.Element, s: Blessed.Widgets.Screen, callback?: Callback): React.Component | null;\n\nexport function createBlessedRenderer(bls: any): renderer;\n\n/* BLESSED ELEMENTS **********************************************************/\n\nexport type Element = Blessed.Widgets.BlessedElement;\nexport type ScrollableBoxElement = Blessed.Widgets.ScrollableBoxElement;\nexport type ScrollableTextElement = Blessed.Widgets.ScrollableTextElement;\nexport type BoxElement = Blessed.Widgets.BoxElement;\nexport type TextElement = Blessed.Widgets.TextElement;\nexport type LineElement = Blessed.Widgets.LineElement;\nexport type BigTextElement = Blessed.Widgets.BigTextElement;\nexport type ListElement = Blessed.Widgets.ListElement;\nexport type FileManagerElement = Blessed.Widgets.FileManagerElement;\nexport type ListTableElement = Blessed.Widgets.ListTableElement;\nexport type ListbarElement = Blessed.Widgets.ListbarElement;\nexport type InputElement = Blessed.Widgets.InputElement;\nexport type TextareaElement = Blessed.Widgets.TextareaElement;\nexport type TextboxElement = Blessed.Widgets.TextboxElement;\nexport type ButtonElement = Blessed.Widgets.ButtonElement;\nexport type CheckboxElement = Blessed.Widgets.CheckboxElement;\nexport type RadioSetElement = Blessed.Widgets.RadioSetElement;\nexport type RadioButtonElement = Blessed.Widgets.RadioButtonElement;\nexport type TableElement = Blessed.Widgets.TableElement;\nexport type PromptElement = Blessed.Widgets.PromptElement;\nexport type QuestionElement = Blessed.Widgets.QuestionElement;\nexport type MessageElement = Blessed.Widgets.MessageElement;\nexport type LoadingElement = Blessed.Widgets.LoadingElement;\nexport type LogElement = Blessed.Widgets.Log;\nexport type ProgressBarElement = Blessed.Widgets.ProgressBarElement;\nexport type TerminalElement = Blessed.Widgets.TerminalElement;\nexport type LayoutElement = Blessed.Widgets.LayoutElement;\n\n/* EVENTS *******************************************************************/\n\ntype Prefix<T extends string, P extends string> = `${T}${P}`;\n\n// create event handlers that map to 'blessed' events. see\n// https://github.com/Yomguithereal/react-blessed/blob/f5e1f791dea1788745695d557040b91f573f9ef5/src/fiber/events.js\ntype EventHandlerProp<T extends string, E extends (...args: never) => void> = {\n    [key in `on${Capitalize<T>}`]?: E;\n};\n\n// 'react-blessed' handles 'blessed' events by matching event names to\n// handlers by prefixing event names with with \"on\" and camelCasing the\n// result. this cannot be fully recreated in TS so we must manually map them\n// here.\ntype ScreenElement = \"click\" | \"mouseover\" | \"mouseout\" | \"mouseup\";\ntype ScreenElementPrefix = \"element\";\ntype ExludedScreenEventNames = Prefix<ScreenElementPrefix, Prefix<\" \", ScreenElement>>;\ntype CamelCasedScreenEventNames = Prefix<ScreenElementPrefix, Capitalize<ScreenElement>>;\n\ntype ScreenEventNames =\n    | Exclude<Blessed.Widgets.NodeScreenEventType, ExludedScreenEventNames>\n    | CamelCasedScreenEventNames;\n\ntype GenericContentPrefix = \"set\" | \"parsed\";\ntype GenericContent = \"content\";\ntype ExludedGenericEventNames = Prefix<GenericContentPrefix, Prefix<\" \", GenericContent>>;\ntype CamelCasedGenericEventNames = Prefix<GenericContentPrefix, Capitalize<GenericContent>>;\n\ntype GenericEventNames =\n    | Exclude<Blessed.Widgets.NodeGenericEventType, ExludedGenericEventNames>\n    | CamelCasedGenericEventNames;\n\ntype ProgressBarEventNames = Parameters<Blessed.Widgets.ProgressBarElement[\"on\"]>[0];\n\ntype SpreadableArgs<T, K = T extends unknown[] ? T : [T]> = K;\n\ninterface EventHandler<T> {\n    (...args: SpreadableArgs<T>): void;\n}\n\n// event args need to be manually typed because Blessed.Widgets.NodeWithEvents\n// overloads the event handlers (making it impossible? to extract the\n// parameters with TS utils) and does not expose the event callbacks as\n// importable types\n\nexport type ScreenEvent = Blessed.Widgets.Screen;\nexport type ScreenEventHandler = EventHandler<ScreenEvent>;\ntype ScreenEventProps = EventHandlerProp<ScreenEventNames, ScreenEventHandler>;\n\nexport type MouseEvent = Blessed.Widgets.Events.IMouseEventArg;\nexport type MouseEventHandler = EventHandler<MouseEvent>;\ntype MouseEventProps = EventHandlerProp<Blessed.Widgets.NodeMouseEventType, MouseEventHandler>;\n\nexport type GenericEvent = undefined;\nexport type GenericEventHandler = EventHandler<GenericEvent>;\ntype GenericEventProps = EventHandlerProp<GenericEventNames, GenericEventHandler>;\n\nexport type KeyPressEvent = [key: any, event: Blessed.Widgets.Events.IKeyEventArg];\nexport type KeyPressEventHandler = EventHandler<KeyPressEvent>;\ntype KeyPressEventProps = EventHandlerProp<\"keypress\", KeyPressEventHandler>;\n\nexport type WarningEvent = string;\nexport type WarningEventHandler = EventHandler<WarningEvent>;\ntype WarningEventProps = EventHandlerProp<\"warning\", WarningEventHandler>;\n\nexport type ProgressBarEvent = undefined;\nexport type ProgressBarEventHandler = EventHandler<ProgressBarEvent>;\ntype ProgressBarEventProps = EventHandlerProp<ProgressBarEventNames, ProgressBarEventHandler>;\ninterface EventProps\n    extends ScreenEventProps, GenericEventProps, MouseEventProps, KeyPressEventProps, WarningEventProps\n{}\n\n/* BLESSED-REACT LOCALLY DEFINED PROPS **************************************/\n\n// @types/blessed defines 'styles' as 'any' but 'blessed' can only can only\n// take certain values. define them here.\n\ninterface BorderStyle {\n    type?: \"line\" | \"bg\";\n    ch?: string;\n    bg?: string;\n    fg?: string;\n    bold?: boolean;\n    underline?: boolean;\n}\ninterface ItemStyle {\n    bg?: string;\n    fg?: string;\n    bold?: boolean;\n    underline?: boolean;\n    blink?: boolean;\n    inverse?: boolean;\n    invisible?: boolean;\n}\ninterface ListStyle extends ElementStyle {\n    selected?: ItemStyle;\n    item?: ItemStyle;\n}\ninterface ProgressBarStyle extends ElementStyle {\n    bar?: { bg?: string; fg?: string };\n}\ninterface ElementStyle extends ItemStyle {\n    border?: BorderStyle;\n    focus?: { bg?: string; fg?: string };\n    hover?: { bg?: string; fg?: string };\n    transparent?: boolean;\n    scrollbar?: { bg?: string; fg?: string; track?: { bg?: string; fg?: string } };\n}\n\n// remove indexers\n// https://stackoverflow.com/questions/51465182/how-to-remove-index-signature-using-mapped-types\ntype KnownKeys<T> = {\n    [K in keyof T as string extends K ? never : number extends K ? never : K]: T[K];\n};\n\ntype WithClassProp<T, K = T | undefined | false | null> = T & { class?: K | K[] };\ntype ProgressBarProps<T> = T extends ProgressBarElement ? ProgressBarEventProps & { style?: ProgressBarStyle } : {};\ntype ListProps<T> = T extends ListElement ? ProgressBarEventProps & { style?: ListStyle; selected?: number } : {};\n// layout does not require prop 'layout' in Blessed.Widgets.LayoutOptions--make it optional\ntype LayoutProps<T> = T extends LayoutElement ? Partial<Blessed.Widgets.LayoutOptions> : {};\n\n// remove {[key: string]: any} indexer defined in Blessed.Widgets.IOptions.\n// 'blessed' doesn't exist in a DOM so it probably doesn't make sense to allow any property\ntype FilterOptions<T extends Record<any, any>> = Partial<Omit<KnownKeys<T>, \"style\" | \"children\">>;\n\ntype ModifiedBlessedOptions<T extends Record<any, any>> = FilterOptions<T> & {\n    children?: React.ReactNode;\n    style?: ElementStyle;\n} & EventProps;\n\n/* REACT-BLESSED JSX ********************************************************/\n\n/**\n * this type can be used to get props for 'react-blessed' elements in the same\n * manner that React.HTMLProps can be used to get DOM element props. e.g.\n * ```ts\n * import { FC } from 'react'\n * import { BlessedProps, BoxElement } from 'react-blessed';\n * type MyBoxProps = BlessedProps<BoxElement>;\n * const MyBox: React.FC<MyBoxProps> = props => <box {...props} />;\n * ```\n * @see DetailedBlessedProps\n * @see React.HTMLAttributes\n */\nexport type BlessedAttributes<E extends Element> = WithClassProp<\n    ModifiedBlessedOptions<E[\"options\"]> & ProgressBarProps<E> & ListProps<E> & LayoutProps<E>\n>;\n\n/**\n * mirrors react prop generation for HTML JSX.IntrinsicElements.\n * @see React.DetailedHTMLProps\n */\nexport type DetailedBlessedProps<E extends Element> = BlessedAttributes<E> & React.ClassAttributes<E>;\n\nexport interface BlessedIntrinsicElements {\n    element: DetailedBlessedProps<Element>;\n    box: DetailedBlessedProps<BoxElement>;\n    scrollablebox: DetailedBlessedProps<ScrollableBoxElement>;\n    scrollabletext: DetailedBlessedProps<ScrollableTextElement>;\n    bigtext: DetailedBlessedProps<BigTextElement>;\n    list: DetailedBlessedProps<ListElement>;\n    filemanager: DetailedBlessedProps<FileManagerElement>;\n    listtable: DetailedBlessedProps<ListTableElement>;\n    listbar: DetailedBlessedProps<ListbarElement>;\n    textbox: DetailedBlessedProps<TextboxElement>;\n    checkbox: DetailedBlessedProps<CheckboxElement>;\n    radioset: DetailedBlessedProps<RadioSetElement>;\n    radiobutton: DetailedBlessedProps<RadioButtonElement>;\n    prompt: DetailedBlessedProps<PromptElement>;\n    question: DetailedBlessedProps<QuestionElement>;\n    message: DetailedBlessedProps<MessageElement>;\n    loading: DetailedBlessedProps<LoadingElement>;\n    log: DetailedBlessedProps<LogElement>;\n    progressbar: DetailedBlessedProps<ProgressBarElement>;\n    terminal: DetailedBlessedProps<Blessed.Widgets.TerminalElement>;\n    layout: DetailedBlessedProps<Blessed.Widgets.LayoutElement>;\n    // escape: Blessed.escape is not an element\n    // program: Blessed.Widgets.Program is not an element\n}\n\n// 'react-blessed' accepts JSX with 'blessed' element names with and wit"
}
