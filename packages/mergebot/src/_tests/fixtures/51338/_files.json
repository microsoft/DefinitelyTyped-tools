{
  "4a7712f61d17eb33e89171f317deeb31b3d555ae:types/koa/tsconfig.json": "{\n    \"files\": [\n        \"index.d.ts\",\n        \"test/index.ts\",\n        \"test/default.ts\",\n        \"test/response-body.ts\",\n        \"test/settings.ts\"\n    ],\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"lib\": [\n            \"es6\"\n        ],\n        \"noImplicitAny\": true,\n        \"noImplicitThis\": true,\n        \"strictNullChecks\": true,\n        \"strictFunctionTypes\": true,\n        \"baseUrl\": \"../\",\n        \"typeRoots\": [\n            \"../\"\n        ],\n        \"types\": [],\n        \"noEmit\": true,\n        \"forceConsistentCasingInFileNames\": true,\n        \"esModuleInterop\": true\n    }\n}\n",
  "master:types/koa/tsconfig.json": "{\n    \"files\": [\n        \"index.d.ts\",\n        \"test/index.ts\",\n        \"test/default.ts\",\n        \"test/response-body.ts\",\n        \"test/settings.ts\"\n    ],\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"lib\": [\n            \"es6\"\n        ],\n        \"noImplicitAny\": true,\n        \"noImplicitThis\": true,\n        \"strictNullChecks\": true,\n        \"strictFunctionTypes\": true,\n        \"baseUrl\": \"../\",\n        \"typeRoots\": [\n            \"../\"\n        ],\n        \"types\": [],\n        \"noEmit\": true,\n        \"forceConsistentCasingInFileNames\": true\n    }\n}\n",
  "master:types/koa/index.d.ts": "// Type definitions for Koa 2.13.0\n// Project: http://koajs.com\n// Definitions by: DavidCai1993 <https://github.com/DavidCai1993>\n//                 jKey Lu <https://github.com/jkeylu>\n//                 Brice Bernard <https://github.com/brikou>\n//                 harryparkdotio <https://github.com/harryparkdotio>\n//                 Wooram Jun <https://github.com/chatoo2412>\n//                 Christian Vaagland Tellnes <https://github.com/tellnes>\n//                 Piotr Kuczynski <https://github.com/pkuczynski>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 3.0\n\n/* =================== USAGE ===================\n\n    import * as Koa from \"koa\"\n    const app = new Koa()\n\n    async function (ctx: Koa.Context, next: Koa.Next) {\n      // ...\n    }\n\n =============================================== */\n/// <reference types=\"node\" />\nimport * as accepts from 'accepts';\nimport * as Cookies from 'cookies';\nimport { EventEmitter } from 'events';\nimport { IncomingMessage, ServerResponse, Server, IncomingHttpHeaders, OutgoingHttpHeaders } from 'http';\nimport { Http2ServerRequest, Http2ServerResponse } from 'http2';\nimport * as httpAssert from 'http-assert';\nimport * as HttpErrors from 'http-errors';\nimport * as Keygrip from 'keygrip';\nimport * as compose from 'koa-compose';\nimport { Socket, ListenOptions } from 'net';\nimport * as url from 'url';\nimport * as contentDisposition from 'content-disposition';\nimport { ParsedUrlQuery } from 'querystring';\n\ndeclare interface ContextDelegatedRequest {\n    /**\n     * Return request header.\n     */\n    header: IncomingHttpHeaders;\n\n    /**\n     * Return request header, alias as request.header\n     */\n    headers: IncomingHttpHeaders;\n\n    /**\n     * Get/Set request URL.\n     */\n    url: string;\n\n    /**\n     * Get origin of URL.\n     */\n    origin: string;\n\n    /**\n     * Get full request URL.\n     */\n    href: string;\n\n    /**\n     * Get/Set request method.\n     */\n    method: string;\n\n    /**\n     * Get request pathname.\n     * Set pathname, retaining the query-string when present.\n     */\n    path: string;\n\n    /**\n     * Get parsed query-string.\n     * Set query-string as an object.\n     */\n    query: ParsedUrlQuery;\n\n    /**\n     * Get/Set query string.\n     */\n    querystring: string;\n\n    /**\n     * Get the search string. Same as the querystring\n     * except it includes the leading ?.\n     *\n     * Set the search string. Same as\n     * response.querystring= but included for ubiquity.\n     */\n    search: string;\n\n    /**\n     * Parse the \"Host\" header field host\n     * and support X-Forwarded-Host when a\n     * proxy is enabled.\n     */\n    host: string;\n\n    /**\n     * Parse the \"Host\" header field hostname\n     * and support X-Forwarded-Host when a\n     * proxy is enabled.\n     */\n    hostname: string;\n\n    /**\n     * Get WHATWG parsed URL object.\n     */\n    URL: url.URL;\n\n    /**\n     * Check if the request is fresh, aka\n     * Last-Modified and/or the ETag\n     * still match.\n     */\n    fresh: boolean;\n\n    /**\n     * Check if the request is stale, aka\n     * \"Last-Modified\" and / or the \"ETag\" for the\n     * resource has changed.\n     */\n    stale: boolean;\n\n    /**\n     * Check if the request is idempotent.\n     */\n    idempotent: boolean;\n\n    /**\n     * Return the request socket.\n     */\n    socket: Socket;\n\n    /**\n     * Return the protocol string \"http\" or \"https\"\n     * when requested with TLS. When the proxy setting\n     * is enabled the \"X-Forwarded-Proto\" header\n     * field will be trusted. If you're running behind\n     * a reverse proxy that supplies https for you this\n     * may be enabled.\n     */\n    protocol: string;\n\n    /**\n     * Short-hand for:\n     *\n     *    this.protocol == 'https'\n     */\n    secure: boolean;\n\n    /**\n     * Request remote address. Supports X-Forwarded-For when app.proxy is true.\n     */\n    ip: string;\n\n    /**\n     * When `app.proxy` is `true`, parse\n     * the \"X-Forwarded-For\" ip address list.\n     *\n     * For example if the value were \"client, proxy1, proxy2\"\n     * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\n     * where \"proxy2\" is the furthest down-stream.\n     */\n    ips: string[];\n\n    /**\n     * Return subdomains as an array.\n     *\n     * Subdomains are the dot-separated parts of the host before the main domain\n     * of the app. By default, the domain of the app is assumed to be the last two\n     * parts of the host. This can be changed by setting `app.subdomainOffset`.\n     *\n     * For example, if the domain is \"tobi.ferrets.example.com\":\n     * If `app.subdomainOffset` is not set, this.subdomains is\n     * `[\"ferrets\", \"tobi\"]`.\n     * If `app.subdomainOffset` is 3, this.subdomains is `[\"tobi\"]`.\n     */\n    subdomains: string[];\n\n    /**\n     * Check if the given `type(s)` is acceptable, returning\n     * the best match when true, otherwise `false`, in which\n     * case you should respond with 406 \"Not Acceptable\".\n     *\n     * The `type` value may be a single mime type string\n     * such as \"application/json\", the extension name\n     * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n     * or array is given the _best_ match, if any is returned.\n     *\n     * Examples:\n     *\n     *     // Accept: text/html\n     *     this.accepts('html');\n     *     // => \"html\"\n     *\n     *     // Accept: text/*, application/json\n     *     this.accepts('html');\n     *     // => \"html\"\n     *     this.accepts('text/html');\n     *     // => \"text/html\"\n     *     this.accepts('json', 'text');\n     *     // => \"json\"\n     *     this.accepts('application/json');\n     *     // => \"application/json\"\n     *\n     *     // Accept: text/*, application/json\n     *     this.accepts('image/png');\n     *     this.accepts('png');\n     *     // => undefined\n     *\n     *     // Accept: text/*;q=.5, application/json\n     *     this.accepts(['html', 'json']);\n     *     this.accepts('html', 'json');\n     *     // => \"json\"\n     */\n    accepts(): string[];\n    accepts(...types: string[]): string | false;\n    accepts(types: string[]): string | false;\n\n    /**\n     * Return accepted encodings or best fit based on `encodings`.\n     *\n     * Given `Accept-Encoding: gzip, deflate`\n     * an array sorted by quality is returned:\n     *\n     *     ['gzip', 'deflate']\n     */\n    acceptsEncodings(): string[];\n    acceptsEncodings(...encodings: string[]): string | false;\n    acceptsEncodings(encodings: string[]): string | false;\n\n    /**\n     * Return accepted charsets or best fit based on `charsets`.\n     *\n     * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n     * an array sorted by quality is returned:\n     *\n     *     ['utf-8', 'utf-7', 'iso-8859-1']\n     */\n    acceptsCharsets(): string[];\n    acceptsCharsets(...charsets: string[]): string | false;\n    acceptsCharsets(charsets: string[]): string | false;\n\n    /**\n     * Return accepted languages or best fit based on `langs`.\n     *\n     * Given `Accept-Language: en;q=0.8, es, pt`\n     * an array sorted by quality is returned:\n     *\n     *     ['es', 'pt', 'en']\n     */\n    acceptsLanguages(): string[];\n    acceptsLanguages(...langs: string[]): string | false;\n    acceptsLanguages(langs: string[]): string | false;\n\n    /**\n     * Check if the incoming request contains the \"Content-Type\"\n     * header field, and it contains any of the give mime `type`s.\n     * If there is no request body, `null` is returned.\n     * If there is no content type, `false` is returned.\n     * Otherwise, it returns the first `type` that matches.\n     *\n     * Examples:\n     *\n     *     // With Content-Type: text/html; charset=utf-8\n     *     this.is('html'); // => 'html'\n     *     this.is('text/html'); // => 'text/html'\n     *     this.is('text/*', 'application/json'); // => 'text/html'\n     *\n     *     // When Content-Type is application/json\n     *     this.is('json', 'urlencoded'); // => 'json'\n     *     this.is('application/json'); // => 'application/json'\n     *     this.is('html', 'application/*'); // => 'application/json'\n     *\n     *     this.is('html'); // => false\n     */\n    // is(): string | boolean;\n    is(...types: string[]): string | false | null;\n    is(types: string[]): string | false | null;\n\n    /**\n     * Return request header. If the header is not set, will return an empty\n     * string.\n     *\n     * The `Referrer` header field is special-cased, both `Referrer` and\n     * `Referer` are interchangeable.\n     *\n     * Examples:\n     *\n     *     this.get('Content-Type');\n     *     // => \"text/plain\"\n     *\n     *     this.get('content-type');\n     *     // => \"text/plain\"\n     *\n     *     this.get('Something');\n     *     // => ''\n     */\n    get(field: string): string;\n}\n\ndeclare interface ContextDelegatedResponse {\n    /**\n     * Get/Set response status code.\n     */\n    status: number;\n\n    /**\n     * Get response status message\n     */\n    message: string;\n\n    /**\n     * Get/Set response body.\n     */\n    body: unknown;\n\n    /**\n     * Return parsed response Content-Length when present.\n     * Set Content-Length field to `n`.\n     */\n    length: number;\n\n    /**\n     * Check if a header has been written to the socket.\n     */\n    headerSent: boolean;\n\n    /**\n     * Vary on `field`.\n     */\n    vary(field: string): void;\n\n    /**\n     * Perform a 302 redirect to `url`.\n     *\n     * The string \"back\" is special-cased\n     * to provide Referrer support, when Referrer\n     * is not present `alt` or \"/\" is used.\n     *\n     * Examples:\n     *\n     *    this.redirect('back');\n     *    this.redirect('back', '/index.html');\n     *    this.redirect('/login');\n     *    this.redirect('http://google.com');\n     */\n    redirect(url: string, alt?: string): void;\n\n    /**\n     * Set Content-Disposition to \"attachment\" to signal the client to prompt for download.\n     * Optionally specify the filename of the download and some options.\n     */\n    attachment(filename?: string, options?: contentDisposition.Options): void;\n\n    /**\n     * Return the response mime type void of\n     * parameters such as \"charset\".\n     *\n     * Set Content-Type response header with `type` through `mime.lookup()`\n     * when it does not contain a charset.\n",
  "4a7712f61d17eb33e89171f317deeb31b3d555ae:types/koa/index.d.ts": "// Type definitions for Koa 2.13.0\n// Project: http://koajs.com\n// Definitions by: DavidCai1993 <https://github.com/DavidCai1993>\n//                 jKey Lu <https://github.com/jkeylu>\n//                 Brice Bernard <https://github.com/brikou>\n//                 harryparkdotio <https://github.com/harryparkdotio>\n//                 Wooram Jun <https://github.com/chatoo2412>\n//                 Christian Vaagland Tellnes <https://github.com/tellnes>\n//                 Piotr Kuczynski <https://github.com/pkuczynski>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 3.0\n\n/* =================== USAGE ===================\n\n    import * as Koa from \"koa\"\n    const app = new Koa()\n\n    async function (ctx: Koa.Context, next: Koa.Next) {\n      // ...\n    }\n\n =============================================== */\n/// <reference types=\"node\" />\nimport * as accepts from 'accepts';\nimport * as Cookies from 'cookies';\nimport { EventEmitter } from 'events';\nimport { IncomingMessage, ServerResponse, Server, IncomingHttpHeaders, OutgoingHttpHeaders } from 'http';\nimport { Http2ServerRequest, Http2ServerResponse } from 'http2';\nimport httpAssert = require('http-assert');\nimport * as HttpErrors from 'http-errors';\nimport * as Keygrip from 'keygrip';\nimport * as compose from 'koa-compose';\nimport { Socket, ListenOptions } from 'net';\nimport * as url from 'url';\nimport * as contentDisposition from 'content-disposition';\nimport { ParsedUrlQuery } from 'querystring';\n\ndeclare interface ContextDelegatedRequest {\n    /**\n     * Return request header.\n     */\n    header: IncomingHttpHeaders;\n\n    /**\n     * Return request header, alias as request.header\n     */\n    headers: IncomingHttpHeaders;\n\n    /**\n     * Get/Set request URL.\n     */\n    url: string;\n\n    /**\n     * Get origin of URL.\n     */\n    origin: string;\n\n    /**\n     * Get full request URL.\n     */\n    href: string;\n\n    /**\n     * Get/Set request method.\n     */\n    method: string;\n\n    /**\n     * Get request pathname.\n     * Set pathname, retaining the query-string when present.\n     */\n    path: string;\n\n    /**\n     * Get parsed query-string.\n     * Set query-string as an object.\n     */\n    query: ParsedUrlQuery;\n\n    /**\n     * Get/Set query string.\n     */\n    querystring: string;\n\n    /**\n     * Get the search string. Same as the querystring\n     * except it includes the leading ?.\n     *\n     * Set the search string. Same as\n     * response.querystring= but included for ubiquity.\n     */\n    search: string;\n\n    /**\n     * Parse the \"Host\" header field host\n     * and support X-Forwarded-Host when a\n     * proxy is enabled.\n     */\n    host: string;\n\n    /**\n     * Parse the \"Host\" header field hostname\n     * and support X-Forwarded-Host when a\n     * proxy is enabled.\n     */\n    hostname: string;\n\n    /**\n     * Get WHATWG parsed URL object.\n     */\n    URL: url.URL;\n\n    /**\n     * Check if the request is fresh, aka\n     * Last-Modified and/or the ETag\n     * still match.\n     */\n    fresh: boolean;\n\n    /**\n     * Check if the request is stale, aka\n     * \"Last-Modified\" and / or the \"ETag\" for the\n     * resource has changed.\n     */\n    stale: boolean;\n\n    /**\n     * Check if the request is idempotent.\n     */\n    idempotent: boolean;\n\n    /**\n     * Return the request socket.\n     */\n    socket: Socket;\n\n    /**\n     * Return the protocol string \"http\" or \"https\"\n     * when requested with TLS. When the proxy setting\n     * is enabled the \"X-Forwarded-Proto\" header\n     * field will be trusted. If you're running behind\n     * a reverse proxy that supplies https for you this\n     * may be enabled.\n     */\n    protocol: string;\n\n    /**\n     * Short-hand for:\n     *\n     *    this.protocol == 'https'\n     */\n    secure: boolean;\n\n    /**\n     * Request remote address. Supports X-Forwarded-For when app.proxy is true.\n     */\n    ip: string;\n\n    /**\n     * When `app.proxy` is `true`, parse\n     * the \"X-Forwarded-For\" ip address list.\n     *\n     * For example if the value were \"client, proxy1, proxy2\"\n     * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\n     * where \"proxy2\" is the furthest down-stream.\n     */\n    ips: string[];\n\n    /**\n     * Return subdomains as an array.\n     *\n     * Subdomains are the dot-separated parts of the host before the main domain\n     * of the app. By default, the domain of the app is assumed to be the last two\n     * parts of the host. This can be changed by setting `app.subdomainOffset`.\n     *\n     * For example, if the domain is \"tobi.ferrets.example.com\":\n     * If `app.subdomainOffset` is not set, this.subdomains is\n     * `[\"ferrets\", \"tobi\"]`.\n     * If `app.subdomainOffset` is 3, this.subdomains is `[\"tobi\"]`.\n     */\n    subdomains: string[];\n\n    /**\n     * Check if the given `type(s)` is acceptable, returning\n     * the best match when true, otherwise `false`, in which\n     * case you should respond with 406 \"Not Acceptable\".\n     *\n     * The `type` value may be a single mime type string\n     * such as \"application/json\", the extension name\n     * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n     * or array is given the _best_ match, if any is returned.\n     *\n     * Examples:\n     *\n     *     // Accept: text/html\n     *     this.accepts('html');\n     *     // => \"html\"\n     *\n     *     // Accept: text/*, application/json\n     *     this.accepts('html');\n     *     // => \"html\"\n     *     this.accepts('text/html');\n     *     // => \"text/html\"\n     *     this.accepts('json', 'text');\n     *     // => \"json\"\n     *     this.accepts('application/json');\n     *     // => \"application/json\"\n     *\n     *     // Accept: text/*, application/json\n     *     this.accepts('image/png');\n     *     this.accepts('png');\n     *     // => undefined\n     *\n     *     // Accept: text/*;q=.5, application/json\n     *     this.accepts(['html', 'json']);\n     *     this.accepts('html', 'json');\n     *     // => \"json\"\n     */\n    accepts(): string[];\n    accepts(...types: string[]): string | false;\n    accepts(types: string[]): string | false;\n\n    /**\n     * Return accepted encodings or best fit based on `encodings`.\n     *\n     * Given `Accept-Encoding: gzip, deflate`\n     * an array sorted by quality is returned:\n     *\n     *     ['gzip', 'deflate']\n     */\n    acceptsEncodings(): string[];\n    acceptsEncodings(...encodings: string[]): string | false;\n    acceptsEncodings(encodings: string[]): string | false;\n\n    /**\n     * Return accepted charsets or best fit based on `charsets`.\n     *\n     * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n     * an array sorted by quality is returned:\n     *\n     *     ['utf-8', 'utf-7', 'iso-8859-1']\n     */\n    acceptsCharsets(): string[];\n    acceptsCharsets(...charsets: string[]): string | false;\n    acceptsCharsets(charsets: string[]): string | false;\n\n    /**\n     * Return accepted languages or best fit based on `langs`.\n     *\n     * Given `Accept-Language: en;q=0.8, es, pt`\n     * an array sorted by quality is returned:\n     *\n     *     ['es', 'pt', 'en']\n     */\n    acceptsLanguages(): string[];\n    acceptsLanguages(...langs: string[]): string | false;\n    acceptsLanguages(langs: string[]): string | false;\n\n    /**\n     * Check if the incoming request contains the \"Content-Type\"\n     * header field, and it contains any of the give mime `type`s.\n     * If there is no request body, `null` is returned.\n     * If there is no content type, `false` is returned.\n     * Otherwise, it returns the first `type` that matches.\n     *\n     * Examples:\n     *\n     *     // With Content-Type: text/html; charset=utf-8\n     *     this.is('html'); // => 'html'\n     *     this.is('text/html'); // => 'text/html'\n     *     this.is('text/*', 'application/json'); // => 'text/html'\n     *\n     *     // When Content-Type is application/json\n     *     this.is('json', 'urlencoded'); // => 'json'\n     *     this.is('application/json'); // => 'application/json'\n     *     this.is('html', 'application/*'); // => 'application/json'\n     *\n     *     this.is('html'); // => false\n     */\n    // is(): string | boolean;\n    is(...types: string[]): string | false | null;\n    is(types: string[]): string | false | null;\n\n    /**\n     * Return request header. If the header is not set, will return an empty\n     * string.\n     *\n     * The `Referrer` header field is special-cased, both `Referrer` and\n     * `Referer` are interchangeable.\n     *\n     * Examples:\n     *\n     *     this.get('Content-Type');\n     *     // => \"text/plain\"\n     *\n     *     this.get('content-type');\n     *     // => \"text/plain\"\n     *\n     *     this.get('Something');\n     *     // => ''\n     */\n    get(field: string): string;\n}\n\ndeclare interface ContextDelegatedResponse {\n    /**\n     * Get/Set response status code.\n     */\n    status: number;\n\n    /**\n     * Get response status message\n     */\n    message: string;\n\n    /**\n     * Get/Set response body.\n     */\n    body: unknown;\n\n    /**\n     * Return parsed response Content-Length when present.\n     * Set Content-Length field to `n`.\n     */\n    length: number;\n\n    /**\n     * Check if a header has been written to the socket.\n     */\n    headerSent: boolean;\n\n    /**\n     * Vary on `field`.\n     */\n    vary(field: string): void;\n\n    /**\n     * Perform a 302 redirect to `url`.\n     *\n     * The string \"back\" is special-cased\n     * to provide Referrer support, when Referrer\n     * is not present `alt` or \"/\" is used.\n     *\n     * Examples:\n     *\n     *    this.redirect('back');\n     *    this.redirect('back', '/index.html');\n     *    this.redirect('/login');\n     *    this.redirect('http://google.com');\n     */\n    redirect(url: string, alt?: string): void;\n\n    /**\n     * Set Content-Disposition to \"attachment\" to signal the client to prompt for download.\n     * Optionally specify the filename of the download and some options.\n     */\n    attachment(filename?: string, options?: contentDisposition.Options): void;\n\n    /**\n     * Return the response mime type void of\n     * parameters such as \"charset\".\n     *\n     * Set Content-Type response header with `type` through `mime.lookup()`\n     * when it does not contain a charset."
}
