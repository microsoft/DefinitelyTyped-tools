{
  "master:types/express-serve-static-core/index.d.ts": "// Type definitions for Express 4.17\n// Project: http://expressjs.com\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\n//                 Micha≈Ç Lytek <https://github.com/19majkel94>\n//                 Kacper Polak <https://github.com/kacepe>\n//                 Satana Charuwichitratana <https://github.com/micksatana>\n//                 Sami Jaber <https://github.com/samijaber>\n//                 aereal <https://github.com/aereal>\n//                 Jose Luis Leon <https://github.com/JoseLion>\n//                 David Stephens <https://github.com/dwrss>\n//                 Shin Ando <https://github.com/andoshin11>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n// This extracts the core definitions from express to prevent a circular dependency between express and serve-static\n/// <reference types=\"node\" />\n\ndeclare global {\n    namespace Express {\n        // These open interfaces may be extended in an application-specific manner via declaration merging.\n        // See for example method-override.d.ts (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/method-override/index.d.ts)\n        interface Request { }\n        interface Response { }\n        interface Application { }\n    }\n}\n\nimport * as http from \"http\";\nimport { EventEmitter } from \"events\";\nimport { Options as RangeParserOptions, Result as RangeParserResult, Ranges as RangeParserRanges } from \"range-parser\";\nimport { ParsedQs } from \"qs\";\n\nexport type Query = ParsedQs;\n\nexport interface NextFunction {\n    (err?: any): void;\n    /**\n     * \"Break-out\" of a router by calling {next('router')};\n     * @see {https://expressjs.com/en/guide/using-middleware.html#middleware.router}\n     */\n    (deferToNext: \"router\"): void;\n}\n\nexport interface Dictionary<T> { [key: string]: T; }\n\nexport interface ParamsDictionary { [key: string]: string; }\nexport type ParamsArray = string[];\nexport type Params = ParamsDictionary | ParamsArray;\n\nexport interface RequestHandler<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs> {\n    // tslint:disable-next-line callable-types (This is extended from and can't extend from a type alias in ts<2.2\n    (req: Request<P, ResBody, ReqBody, ReqQuery>, res: Response<ResBody>, next: NextFunction): any;\n}\n\nexport type ErrorRequestHandler<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs> =\n    (err: any, req: Request<P, ResBody, ReqBody, ReqQuery>, res: Response<ResBody>, next: NextFunction) => any;\n\nexport type PathParams = string | RegExp | Array<string | RegExp>;\n\nexport type RequestHandlerParams<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs>\n    = RequestHandler<P, ResBody, ReqBody, ReqQuery>\n    | ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery>\n    | Array<RequestHandler<P>\n    | ErrorRequestHandler<P>>;\n\nexport interface IRouterMatcher<T, Method extends 'all' | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head' = any> {\n    // tslint:disable-next-line no-unnecessary-generics (This generic is meant to be passed explicitly.)\n    <P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs>(path: PathParams, ...handlers: Array<RequestHandler<P, ResBody, ReqBody, ReqQuery>>): T;\n    // tslint:disable-next-line no-unnecessary-generics (This generic is meant to be passed explicitly.)\n    <P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs>(path: PathParams, ...handlers: Array<RequestHandlerParams<P, ResBody, ReqBody, ReqQuery>>): T;\n    (path: PathParams, subApplication: Application): T;\n}\n\nexport interface IRouterHandler<T> {\n    (...handlers: RequestHandler[]): T;\n    (...handlers: RequestHandlerParams[]): T;\n}\n\nexport interface IRouter extends RequestHandler {\n    /**\n     * Map the given param placeholder `name`(s) to the given callback(s).\n     *\n     * Parameter mapping is used to provide pre-conditions to routes\n     * which use normalized placeholders. For example a _:user_id_ parameter\n     * could automatically load a user's information from the database without\n     * any additional code,\n     *\n     * The callback uses the samesignature as middleware, the only differencing\n     * being that the value of the placeholder is passed, in this case the _id_\n     * of the user. Once the `next()` function is invoked, just like middleware\n     * it will continue on to execute the route, or subsequent parameter functions.\n     *\n     *      app.param('user_id', function(req, res, next, id){\n     *        User.find(id, function(err, user){\n     *          if (err) {\n     *            next(err);\n     *          } else if (user) {\n     *            req.user = user;\n     *            next();\n     *          } else {\n     *            next(new Error('failed to load user'));\n     *          }\n     *        });\n     *      });\n     */\n    param(name: string, handler: RequestParamHandler): this;\n\n    /**\n     * Alternatively, you can pass only a callback, in which case you have the opportunity to alter the app.param()\n     *\n     * @deprecated since version 4.11\n     */\n    param(callback: (name: string, matcher: RegExp) => RequestParamHandler): this;\n\n    /**\n     * Special-cased \"all\" method, applying the given route `path`,\n     * middleware, and callback to _every_ HTTP method.\n     */\n    all: IRouterMatcher<this, 'all'>;\n    get: IRouterMatcher<this, 'get'>;\n    post: IRouterMatcher<this, 'post'>;\n    put: IRouterMatcher<this, 'put'>;\n    delete: IRouterMatcher<this, 'delete'>;\n    patch: IRouterMatcher<this, 'patch'>;\n    options: IRouterMatcher<this, 'options'>;\n    head: IRouterMatcher<this, 'head'>;\n\n    checkout: IRouterMatcher<this>;\n    connect: IRouterMatcher<this>;\n    copy: IRouterMatcher<this>;\n    lock: IRouterMatcher<this>;\n    merge: IRouterMatcher<this>;\n    mkactivity: IRouterMatcher<this>;\n    mkcol: IRouterMatcher<this>;\n    move: IRouterMatcher<this>;\n    \"m-search\": IRouterMatcher<this>;\n    notify: IRouterMatcher<this>;\n    propfind: IRouterMatcher<this>;\n    proppatch: IRouterMatcher<this>;\n    purge: IRouterMatcher<this>;\n    report: IRouterMatcher<this>;\n    search: IRouterMatcher<this>;\n    subscribe: IRouterMatcher<this>;\n    trace: IRouterMatcher<this>;\n    unlock: IRouterMatcher<this>;\n    unsubscribe: IRouterMatcher<this>;\n\n    use: IRouterHandler<this> & IRouterMatcher<this>;\n\n    route(prefix: PathParams): IRoute;\n    /**\n     * Stack of configured routes\n     */\n    stack: any[];\n}\n\nexport interface IRoute {\n    path: string;\n    stack: any;\n    all: IRouterHandler<this>;\n    get: IRouterHandler<this>;\n    post: IRouterHandler<this>;\n    put: IRouterHandler<this>;\n    delete: IRouterHandler<this>;\n    patch: IRouterHandler<this>;\n    options: IRouterHandler<this>;\n    head: IRouterHandler<this>;\n\n    checkout: IRouterHandler<this>;\n    copy: IRouterHandler<this>;\n    lock: IRouterHandler<this>;\n    merge: IRouterHandler<this>;\n    mkactivity: IRouterHandler<this>;\n    mkcol: IRouterHandler<this>;\n    move: IRouterHandler<this>;\n    \"m-search\": IRouterHandler<this>;\n    notify: IRouterHandler<this>;\n    purge: IRouterHandler<this>;\n    report: IRouterHandler<this>;\n    search: IRouterHandler<this>;\n    subscribe: IRouterHandler<this>;\n    trace: IRouterHandler<this>;\n    unlock: IRouterHandler<this>;\n    unsubscribe: IRouterHandler<this>;\n}\n\nexport interface Router extends IRouter { }\n\nexport interface CookieOptions {\n    maxAge?: number;\n    signed?: boolean;\n    expires?: Date;\n    httpOnly?: boolean;\n    path?: string;\n    domain?: string;\n    secure?: boolean;\n    encode?: (val: string) => string;\n    sameSite?: boolean | 'lax' | 'strict' | 'none';\n}\n\nexport interface ByteRange { start: number; end: number; }\n\nexport interface RequestRanges extends RangeParserRanges { }\n\nexport type Errback = (err: Error) => void;\n\n/**\n * @param P  For most requests, this should be `ParamsDictionary`, but if you're\n * using this in a route handler for a route that uses a `RegExp` or a wildcard\n * `string` path (e.g. `'/user/*'`), then `req.params` will be an array, in\n * which case you should use `ParamsArray` instead.\n *\n * @see https://expressjs.com/en/api.html#req.params\n *\n * @example\n *     app.get('/user/:id', (req, res) => res.send(req.params.id)); // implicitly `ParamsDictionary`\n *     app.get<ParamsArray>(/user\\/(.*)/, (req, res) => res.send(req.params[0]));\n *     app.get<ParamsArray>('/user/*', (req, res) => res.send(req.params[0]));\n */\nexport interface Request<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs> extends http.IncomingMessage, Express.Request {\n    /**\n     * Return request header.\n     *\n     * The `Referrer` header field is special-cased,\n     * both `Referrer` and `Referer` are interchangeable.\n     *\n     * Examples:\n     *\n     *     req.get('Content-Type');\n     *     // => \"text/plain\"\n     *\n     *     req.get('content-type');\n     *     // => \"text/plain\"\n     *\n     *     req.get('Something');\n     *     // => undefined\n     *\n     * Aliased as `req.header()`.\n     */\n    get(name: \"set-cookie\"): string[] | undefined;\n    get(name: string): string | undefined;\n\n    header(name: \"set-cookie\"): string[] | undefined;\n    header(name: string): string | undefined;\n\n    /**\n     * Check if the given `type(s)` is acceptable, returning\n     * the best match when true, otherwise `undefined`, in which\n     * case you should respond with 406 \"Not Acceptable\".\n     *\n     * The `type` value may be a single mime type string\n     * such as \"application/json\", the extension name\n     * such as \"json\", a comma-delimted list such as \"json, html, text/plain\",\n     * or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n     * or array is given the _best_ match, if any is returned.\n     *\n     * Examples:\n     *\n     *     // Accept: text/html\n     *     req.accepts('html');\n     *     // => \"html\"\n     *\n     *     // Accept: text/*, application/json\n     *     req.accepts('html');\n     *     // => \"html\"\n     *     req.accepts('text/html');\n     *     // => \"text/html\"\n     *     req.accepts('json, text');\n     *     // => \"json\"",
  "dbe687d30362e4f887e88048a3646c13c0c4d907:types/express-serve-static-core/index.d.ts": "// Type definitions for Express 4.17\n// Project: http://expressjs.com\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\n//                 Micha≈Ç Lytek <https://github.com/19majkel94>\n//                 Kacper Polak <https://github.com/kacepe>\n//                 Satana Charuwichitratana <https://github.com/micksatana>\n//                 Sami Jaber <https://github.com/samijaber>\n//                 aereal <https://github.com/aereal>\n//                 Jose Luis Leon <https://github.com/JoseLion>\n//                 David Stephens <https://github.com/dwrss>\n//                 Shin Ando <https://github.com/andoshin11>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n// This extracts the core definitions from express to prevent a circular dependency between express and serve-static\n/// <reference types=\"node\" />\n\ndeclare global {\n    namespace Express {\n        // These open interfaces may be extended in an application-specific manner via declaration merging.\n        // See for example method-override.d.ts (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/method-override/index.d.ts)\n        interface Request { }\n        interface Response { }\n        interface Application { }\n    }\n}\n\nimport * as http from \"http\";\nimport { EventEmitter } from \"events\";\nimport { Options as RangeParserOptions, Result as RangeParserResult, Ranges as RangeParserRanges } from \"range-parser\";\nimport { ParsedQs } from \"qs\";\n\nexport type Query = ParsedQs;\n\nexport interface NextFunction {\n    (err?: any): void;\n    /**\n     * \"Break-out\" of a router by calling {next('router')};\n     * @see {https://expressjs.com/en/guide/using-middleware.html#middleware.router}\n     */\n    (deferToNext: \"router\"): void;\n}\n\nexport interface Dictionary<T> { [key: string]: T; }\n\nexport interface ParamsDictionary { [key: string]: string; }\nexport type ParamsArray = string[];\nexport type Params = ParamsDictionary | ParamsArray;\n\nexport interface RequestHandler<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs> {\n    // tslint:disable-next-line callable-types (This is extended from and can't extend from a type alias in ts<2.2\n    (req: Request<P, ResBody, ReqBody, ReqQuery>, res: Response<ResBody>, next: NextFunction): any;\n}\n\nexport type ErrorRequestHandler<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs> =\n    (err: any, req: Request<P, ResBody, ReqBody, ReqQuery>, res: Response<ResBody>, next: NextFunction) => any;\n\nexport type PathParams = string | RegExp | Array<string | RegExp>;\n\nexport type RequestHandlerParams<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs>\n    = RequestHandler<P, ResBody, ReqBody, ReqQuery>\n    | ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery>\n    | Array<RequestHandler<P>\n    | ErrorRequestHandler<P>>;\n\nexport interface IRouterMatcher<T, Method extends 'all' | 'get' | 'post' | 'put' | 'delete' | 'patch' | 'options' | 'head' = any> {\n    // tslint:disable-next-line no-unnecessary-generics (This generic is meant to be passed explicitly.)\n    <P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs>(path: PathParams, ...handlers: Array<RequestHandler<P, ResBody, ReqBody, ReqQuery>>): T;\n    // tslint:disable-next-line no-unnecessary-generics (This generic is meant to be passed explicitly.)\n    <P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs>(path: PathParams, ...handlers: Array<RequestHandlerParams<P, ResBody, ReqBody, ReqQuery>>): T;\n    (path: PathParams, subApplication: Application): T;\n}\n\nexport interface IRouterHandler<T> {\n    (...handlers: RequestHandler[]): T;\n    (...handlers: RequestHandlerParams[]): T;\n}\n\nexport interface IRouter extends RequestHandler {\n    /**\n     * Map the given param placeholder `name`(s) to the given callback(s).\n     *\n     * Parameter mapping is used to provide pre-conditions to routes\n     * which use normalized placeholders. For example a _:user_id_ parameter\n     * could automatically load a user's information from the database without\n     * any additional code,\n     *\n     * The callback uses the samesignature as middleware, the only differencing\n     * being that the value of the placeholder is passed, in this case the _id_\n     * of the user. Once the `next()` function is invoked, just like middleware\n     * it will continue on to execute the route, or subsequent parameter functions.\n     *\n     *      app.param('user_id', function(req, res, next, id){\n     *        User.find(id, function(err, user){\n     *          if (err) {\n     *            next(err);\n     *          } else if (user) {\n     *            req.user = user;\n     *            next();\n     *          } else {\n     *            next(new Error('failed to load user'));\n     *          }\n     *        });\n     *      });\n     */\n    param(name: string, handler: RequestParamHandler): this;\n\n    /**\n     * Alternatively, you can pass only a callback, in which case you have the opportunity to alter the app.param()\n     *\n     * @deprecated since version 4.11\n     */\n    param(callback: (name: string, matcher: RegExp) => RequestParamHandler): this;\n\n    /**\n     * Special-cased \"all\" method, applying the given route `path`,\n     * middleware, and callback to _every_ HTTP method.\n     */\n    all: IRouterMatcher<this, 'all'>;\n    get: IRouterMatcher<this, 'get'>;\n    post: IRouterMatcher<this, 'post'>;\n    put: IRouterMatcher<this, 'put'>;\n    delete: IRouterMatcher<this, 'delete'>;\n    patch: IRouterMatcher<this, 'patch'>;\n    options: IRouterMatcher<this, 'options'>;\n    head: IRouterMatcher<this, 'head'>;\n\n    checkout: IRouterMatcher<this>;\n    connect: IRouterMatcher<this>;\n    copy: IRouterMatcher<this>;\n    lock: IRouterMatcher<this>;\n    merge: IRouterMatcher<this>;\n    mkactivity: IRouterMatcher<this>;\n    mkcol: IRouterMatcher<this>;\n    move: IRouterMatcher<this>;\n    \"m-search\": IRouterMatcher<this>;\n    notify: IRouterMatcher<this>;\n    propfind: IRouterMatcher<this>;\n    proppatch: IRouterMatcher<this>;\n    purge: IRouterMatcher<this>;\n    report: IRouterMatcher<this>;\n    search: IRouterMatcher<this>;\n    subscribe: IRouterMatcher<this>;\n    trace: IRouterMatcher<this>;\n    unlock: IRouterMatcher<this>;\n    unsubscribe: IRouterMatcher<this>;\n\n    use: IRouterHandler<this> & IRouterMatcher<this>;\n\n    route(prefix: PathParams): IRoute;\n    /**\n     * Stack of configured routes\n     */\n    stack: any[];\n}\n\nexport interface IRoute {\n    path: string;\n    stack: any;\n    all: IRouterHandler<this>;\n    get: IRouterHandler<this>;\n    post: IRouterHandler<this>;\n    put: IRouterHandler<this>;\n    delete: IRouterHandler<this>;\n    patch: IRouterHandler<this>;\n    options: IRouterHandler<this>;\n    head: IRouterHandler<this>;\n\n    checkout: IRouterHandler<this>;\n    copy: IRouterHandler<this>;\n    lock: IRouterHandler<this>;\n    merge: IRouterHandler<this>;\n    mkactivity: IRouterHandler<this>;\n    mkcol: IRouterHandler<this>;\n    move: IRouterHandler<this>;\n    \"m-search\": IRouterHandler<this>;\n    notify: IRouterHandler<this>;\n    purge: IRouterHandler<this>;\n    report: IRouterHandler<this>;\n    search: IRouterHandler<this>;\n    subscribe: IRouterHandler<this>;\n    trace: IRouterHandler<this>;\n    unlock: IRouterHandler<this>;\n    unsubscribe: IRouterHandler<this>;\n}\n\nexport interface Router extends IRouter { }\n\nexport interface CookieOptions {\n    maxAge?: number;\n    signed?: boolean;\n    expires?: Date;\n    httpOnly?: boolean;\n    path?: string;\n    domain?: string;\n    secure?: boolean;\n    encode?: (val: string) => string;\n    sameSite?: boolean | 'lax' | 'strict' | 'none';\n}\n\nexport interface ByteRange { start: number; end: number; }\n\nexport interface RequestRanges extends RangeParserRanges { }\n\nexport type Errback = (err: Error) => void;\n\n/**\n * @param P  For most requests, this should be `ParamsDictionary`, but if you're\n * using this in a route handler for a route that uses a `RegExp` or a wildcard\n * `string` path (e.g. `'/user/*'`), then `req.params` will be an array, in\n * which case you should use `ParamsArray` instead.\n *\n * @see https://expressjs.com/en/api.html#req.params\n *\n * @example\n *     app.get('/user/:id', (req, res) => res.send(req.params.id)); // implicitly `ParamsDictionary`\n *     app.get<ParamsArray>(/user\\/(.*)/, (req, res) => res.send(req.params[0]));\n *     app.get<ParamsArray>('/user/*', (req, res) => res.send(req.params[0]));\n */\nexport interface Request<P extends Params = ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = ParsedQs> extends http.IncomingMessage, Express.Request {\n    /**\n     * Return request header.\n     *\n     * The `Referrer` header field is special-cased,\n     * both `Referrer` and `Referer` are interchangeable.\n     *\n     * Examples:\n     *\n     *     req.get('Content-Type');\n     *     // => \"text/plain\"\n     *\n     *     req.get('content-type');\n     *     // => \"text/plain\"\n     *\n     *     req.get('Something');\n     *     // => undefined\n     *\n     * Aliased as `req.header()`.\n     */\n    get(name: \"set-cookie\"): string[] | undefined;\n    get(name: string): string | undefined;\n\n    header(name: \"set-cookie\"): string[] | undefined;\n    header(name: string): string | undefined;\n\n    /**\n     * Check if the given `type(s)` is acceptable, returning\n     * the best match when true, otherwise `undefined`, in which\n     * case you should respond with 406 \"Not Acceptable\".\n     *\n     * The `type` value may be a single mime type string\n     * such as \"application/json\", the extension name\n     * such as \"json\", a comma-delimted list such as \"json, html, text/plain\",\n     * or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n     * or array is given the _best_ match, if any is returned.\n     *\n     * Examples:\n     *\n     *     // Accept: text/html\n     *     req.accepts('html');\n     *     // => \"html\"\n     *\n     *     // Accept: text/*, application/json\n     *     req.accepts('html');\n     *     // => \"html\"\n     *     req.accepts('text/html');\n     *     // => \"text/html\"\n     *     req.accepts('json, text');\n     *     // => \"json\"",
  "master:types/express/index.d.ts": "// Type definitions for Express 4.17\n// Project: http://expressjs.com\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\n//                 China Medical University Hospital <https://github.com/CMUH>\n//                 Puneet Arora <https://github.com/puneetar>\n//                 Dylan Frankland <https://github.com/dfrankland>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/* =================== USAGE ===================\n\n    import express = require(\"express\");\n    var app = express();\n\n =============================================== */\n\n/// <reference types=\"express-serve-static-core\" />\n/// <reference types=\"serve-static\" />\n\nimport * as bodyParser from \"body-parser\";\nimport serveStatic = require(\"serve-static\");\nimport * as core from \"express-serve-static-core\";\nimport * as qs from \"qs\";\n\n/**\n * Creates an Express application. The express() function is a top-level function exported by the express module.\n */\ndeclare function e(): core.Express;\n\ndeclare namespace e {\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with JSON payloads and is based on body-parser.\n     * @since 4.16.0\n     */\n    var json: typeof bodyParser.json;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with Buffer payloads and is based on body-parser.\n     * @since 4.17.0\n     */\n    var raw: typeof bodyParser.raw;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with text payloads and is based on body-parser.\n     * @since 4.17.0\n     */\n    var text: typeof bodyParser.text;\n\n    /**\n     * These are the exposed prototypes.\n     */\n    var application: Application;\n    var request: Request;\n    var response: Response;\n\n    /**\n     * This is a built-in middleware function in Express. It serves static files and is based on serve-static.\n     */\n    var static: typeof serveStatic;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with urlencoded payloads and is based on body-parser.\n     * @since 4.16.0\n     */\n    var urlencoded: typeof bodyParser.urlencoded;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming request query parameters.\n     */\n    export function query(options: qs.IParseOptions | typeof qs.parse): Handler;\n\n    export function Router(options?: RouterOptions): core.Router;\n\n    interface RouterOptions {\n        /**\n         * Enable case sensitivity.\n         */\n        caseSensitive?: boolean;\n\n        /**\n         * Preserve the req.params values from the parent router.\n         * If the parent and the child have conflicting param names, the child‚Äôs value take precedence.\n         *\n         * @default false\n         * @since 4.5.0\n         */\n        mergeParams?: boolean;\n\n        /**\n         * Enable strict routing.\n         */\n        strict?: boolean;\n    }\n\n    interface Application extends core.Application { }\n    interface CookieOptions extends core.CookieOptions { }\n    interface Errback extends core.Errback { }\n    interface ErrorRequestHandler<P extends core.Params = core.ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = core.Query>\n        extends core.ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery> { }\n    interface Express extends core.Express { }\n    interface Handler extends core.Handler { }\n    interface IRoute extends core.IRoute { }\n    interface IRouter extends core.IRouter { }\n    interface IRouterHandler<T> extends core.IRouterHandler<T> { }\n    interface IRouterMatcher<T> extends core.IRouterMatcher<T> { }\n    interface MediaType extends core.MediaType { }\n    interface NextFunction extends core.NextFunction { }\n    interface Request<P extends core.Params = core.ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = core.Query> extends core.Request<P, ResBody, ReqBody, ReqQuery> { }\n    interface RequestHandler<P extends core.Params = core.ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = core.Query> extends core.RequestHandler<P, ResBody, ReqBody, ReqQuery> { }\n    interface RequestParamHandler extends core.RequestParamHandler { }\n    export interface Response<ResBody = any> extends core.Response<ResBody> { }\n    interface Router extends core.Router { }\n    interface Send extends core.Send { }\n}\n\nexport = e;\n",
  "dbe687d30362e4f887e88048a3646c13c0c4d907:types/express/index.d.ts": "// Type definitions for Express 4.17\n// Project: http://expressjs.com\n// Definitions by: Boris Yankov <https://github.com/borisyankov>\n//                 China Medical University Hospital <https://github.com/CMUH>\n//                 Puneet Arora <https://github.com/puneetar>\n//                 Dylan Frankland <https://github.com/dfrankland>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/* =================== USAGE ===================\n\n    import express = require(\"express\");\n    var app = express();\n\n =============================================== */\n\n/// <reference types=\"express-serve-static-core\" />\n/// <reference types=\"serve-static\" />\n\nimport * as bodyParser from \"body-parser\";\nimport serveStatic = require(\"serve-static\");\nimport * as core from \"express-serve-static-core\";\nimport * as qs from \"qs\";\n\n/**\n * Creates an Express application. The express() function is a top-level function exported by the express module.\n */\ndeclare function e(): core.Express;\n\ndeclare namespace e {\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with JSON payloads and is based on body-parser.\n     * @since 4.16.0\n     */\n    var json: typeof bodyParser.json;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with Buffer payloads and is based on body-parser.\n     * @since 4.17.0\n     */\n    var raw: typeof bodyParser.raw;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with text payloads and is based on body-parser.\n     * @since 4.17.0\n     */\n    var text: typeof bodyParser.text;\n\n    /**\n     * These are the exposed prototypes.\n     */\n    var application: Application;\n    var request: Request;\n    var response: Response;\n\n    /**\n     * This is a built-in middleware function in Express. It serves static files and is based on serve-static.\n     */\n    var static: typeof serveStatic;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming requests with urlencoded payloads and is based on body-parser.\n     * @since 4.16.0\n     */\n    var urlencoded: typeof bodyParser.urlencoded;\n\n    /**\n     * This is a built-in middleware function in Express. It parses incoming request query parameters.\n     */\n    export function query(options: qs.IParseOptions | typeof qs.parse): Handler;\n\n    export function Router(options?: RouterOptions): core.Router;\n\n    interface RouterOptions {\n        /**\n         * Enable case sensitivity.\n         */\n        caseSensitive?: boolean;\n\n        /**\n         * Preserve the req.params values from the parent router.\n         * If the parent and the child have conflicting param names, the child‚Äôs value take precedence.\n         *\n         * @default false\n         * @since 4.5.0\n         */\n        mergeParams?: boolean;\n\n        /**\n         * Enable strict routing.\n         */\n        strict?: boolean;\n    }\n\n    interface Application extends core.Application { }\n    interface CookieOptions extends core.CookieOptions { }\n    interface Errback extends core.Errback { }\n    interface ErrorRequestHandler<P extends core.Params = core.ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = core.Query>\n        extends core.ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery> { }\n    interface Express extends core.Express { }\n    interface Handler extends core.Handler { }\n    interface IRoute extends core.IRoute { }\n    interface IRouter extends core.IRouter { }\n    interface IRouterHandler<T> extends core.IRouterHandler<T> { }\n    interface IRouterMatcher<T> extends core.IRouterMatcher<T> { }\n    interface MediaType extends core.MediaType { }\n    interface NextFunction extends core.NextFunction { }\n    interface Request<P extends core.Params = core.ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = core.Query> extends core.Request<P, ResBody, ReqBody, ReqQuery> { }\n    interface RequestHandler<P extends core.Params = core.ParamsDictionary, ResBody = any, ReqBody = any, ReqQuery = core.Query> extends core.RequestHandler<P, ResBody, ReqBody, ReqQuery> { }\n    interface RequestParamHandler extends core.RequestParamHandler { }\n    export interface Response<ResBody = any> extends core.Response<ResBody> { }\n    interface Router extends core.Router { }\n    interface Send extends core.Send { }\n}\n\nexport = e;\n"
}
