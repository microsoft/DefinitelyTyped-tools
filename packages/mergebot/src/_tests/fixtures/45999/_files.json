{
  "master:types/react/index.d.ts": "// Type definitions for React 16.9\n// Project: http://facebook.github.io/react/\n// Definitions by: Asana <https://asana.com>\n//                 AssureSign <http://www.assuresign.com>\n//                 Microsoft <https://microsoft.com>\n//                 John Reilly <https://github.com/johnnyreilly>\n//                 Benoit Benezech <https://github.com/bbenezech>\n//                 Patricio Zavolinsky <https://github.com/pzavolinsky>\n//                 Digiguru <https://github.com/digiguru>\n//                 Eric Anderson <https://github.com/ericanderson>\n//                 Dovydas Navickas <https://github.com/DovydasNavickas>\n//                 Josh Rutherford <https://github.com/theruther4d>\n//                 Guilherme Hübner <https://github.com/guilhermehubner>\n//                 Ferdy Budhidharma <https://github.com/ferdaber>\n//                 Johann Rakotoharisoa <https://github.com/jrakotoharisoa>\n//                 Olivier Pascal <https://github.com/pascaloliv>\n//                 Martin Hochel <https://github.com/hotell>\n//                 Frank Li <https://github.com/franklixuefei>\n//                 Jessica Franco <https://github.com/Jessidhia>\n//                 Saransh Kataria <https://github.com/saranshkataria>\n//                 Kanitkorn Sujautra <https://github.com/lukyth>\n//                 Sebastian Silbermann <https://github.com/eps1lon>\n//                 Kyle Scully <https://github.com/zieka>\n//                 Cong Zhang <https://github.com/dancerphil>\n//                 Dimitri Mitropoulos <https://github.com/dimitropoulos>\n//                 JongChan Choi <https://github.com/disjukr>\n//                 Victor Magalhães <https://github.com/vhfmag>\n//                 Dale Tan <https://github.com/hellatan>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.8\n\n// NOTE: Users of the `experimental` builds of React should add a reference\n// to 'react/experimental' in their project. See experimental.d.ts's top comment\n// for reference and documentation on how exactly to do it.\n\n/// <reference path=\"global.d.ts\" />\n\nimport * as CSS from 'csstype';\nimport * as PropTypes from 'prop-types';\n\ntype NativeAnimationEvent = AnimationEvent;\ntype NativeClipboardEvent = ClipboardEvent;\ntype NativeCompositionEvent = CompositionEvent;\ntype NativeDragEvent = DragEvent;\ntype NativeFocusEvent = FocusEvent;\ntype NativeKeyboardEvent = KeyboardEvent;\ntype NativeMouseEvent = MouseEvent;\ntype NativeTouchEvent = TouchEvent;\ntype NativePointerEvent = PointerEvent;\ntype NativeTransitionEvent = TransitionEvent;\ntype NativeUIEvent = UIEvent;\ntype NativeWheelEvent = WheelEvent;\ntype Booleanish = boolean | 'true' | 'false';\n\n/**\n * defined in scheduler/tracing\n */\ninterface SchedulerInteraction {\n    id: number;\n    name: string;\n    timestamp: number;\n}\n\n// tslint:disable-next-line:export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\n\n    type ElementType<P = any> =\n        {\n            [K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never\n        }[keyof JSX.IntrinsicElements] |\n        ComponentType<P>;\n    /**\n     * @deprecated Please use `ElementType`\n     */\n    type ReactType<P = any> = ElementType<P>;\n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\n\n    type JSXElementConstructor<P> =\n        | ((props: P) => ReactElement | null)\n        | (new (props: P) => Component<P, any>);\n\n    interface RefObject<T> {\n        readonly current: T | null;\n    }\n    type RefCallback<T> = { bivarianceHack(instance: T | null): void }[\"bivarianceHack\"];\n    type Ref<T> = RefCallback<T> | RefObject<T> | null;\n    type LegacyRef<T> = string | Ref<T>;\n    /**\n     * Gets the instance type for a React element. The instance will be different for various component types:\n     *\n     * - React class components will be the class instance. So if you had `class Foo extends React.Component<{}> {}`\n     *   and used `React.ElementRef<typeof Foo>` then the type would be the instance of `Foo`.\n     * - React stateless functional components do not have a backing instance and so `React.ElementRef<typeof Bar>`\n     *   (when `Bar` is `function Bar() {}`) will give you the `undefined` type.\n     * - JSX intrinsics like `div` will give you their DOM instance. For `React.ElementRef<'div'>` that would be\n     *   `HTMLDivElement`. For `React.ElementRef<'input'>` that would be `HTMLInputElement`.\n     * - React stateless functional components that forward a `ref` will give you the `ElementRef` of the forwarded\n     *   to component.\n     *\n     * `C` must be the type _of_ a React component so you need to use typeof as in React.ElementRef<typeof MyComponent>.\n     *\n     * @todo In Flow, this works a little different with forwarded refs and the `AbstractComponent` that\n     *       `React.forwardRef()` returns.\n     */\n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new (props: any): Component<any> }\n            | ((props: any, context?: any) => ReactElement | null)\n            | keyof JSX.IntrinsicElements\n    > =\n        // need to check first if `ref` is a valid prop for ts@3.0\n        // otherwise it will infer `{}` instead of `never`\n        \"ref\" extends keyof ComponentPropsWithRef<C>\n            ? NonNullable<ComponentPropsWithRef<C>[\"ref\"]> extends Ref<\n                infer Instance\n            >\n                ? Instance\n                : never\n            : never;\n\n    type ComponentState = any;\n\n    type Key = string | number;\n\n    /**\n     * @internal You shouldn't need to use this type since you never see these attributes\n     * inside your component or have to validate them.\n     */\n    interface Attributes {\n        key?: Key;\n    }\n    interface RefAttributes<T> extends Attributes {\n        ref?: Ref<T>;\n    }\n    interface ClassAttributes<T> extends Attributes {\n        ref?: LegacyRef<T>;\n    }\n\n    interface ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> {\n        type: T;\n        props: P;\n        key: Key | null;\n    }\n\n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, 'key' | 'ref'>>\n    > extends ReactElement<P, Exclude<T, number>> { }\n\n    /**\n     * @deprecated Please use `FunctionComponentElement`\n     */\n    type SFCElement<P> = FunctionComponentElement<P>;\n\n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n        ref?: 'ref' extends keyof P ? P extends { ref?: infer R } ? R : never : never;\n    }\n\n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n        ref?: LegacyRef<T>;\n    }\n\n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element> extends ReactElement<P, string> {\n        ref: LegacyRef<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    // tslint:disable-next-line:no-empty-interface\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> { }\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: keyof ReactHTML;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: keyof ReactSVG;\n    }\n\n    interface ReactPortal extends ReactElement {\n        key: Key | null;\n        children: ReactNode;\n    }\n\n    //\n    // Factories\n    // ----------------------------------------------------------------------\n\n    type Factory<P> = (props?: Attributes & P, ...children: ReactNode[]) => ReactElement<P>;\n\n    /**\n     * @deprecated Please use `FunctionComponentFactory`\n     */\n    type SFCFactory<P> = FunctionComponentFactory<P>;\n\n    type FunctionComponentFactory<P> = (props?: Attributes & P, ...children: ReactNode[]) => FunctionComponentElement<P>;\n\n    type ComponentFactory<P, T extends Component<P, ComponentState>> =\n        (props?: ClassAttributes<T> & P, ...children: ReactNode[]) => CElement<P, T>;\n\n    type CFactory<P, T extends Component<P, ComponentState>> = ComponentFactory<P, T>;\n    type ClassicFactory<P> = CFactory<P, ClassicComponent<P, ComponentState>>;\n\n    type DOMFactory<P extends DOMAttributes<T>, T extends Element> =\n        (props?: ClassAttributes<T> & P | null, ...children: ReactNode[]) => DOMElement<P, T>;\n\n    // tslint:disable-next-line:no-empty-interface\n    interface HTMLFactory<T extends HTMLElement> extends DetailedHTMLFactory<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedHTMLFactory<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMFactory<P, T> {\n        (props?: ClassAttributes<T> & P | null, ...children: ReactNode[]): DetailedReactHTMLElement<P, T>;\n    }\n\n    interface SVGFactory extends DOMFactory<SVGAttributes<SVGElement>, SVGElement> {\n        (props?: ClassAttributes<SVGElement> & SVGAttributes<SVGElement> | null, ...children: ReactNode[]): ReactSVGElement;\n    }\n\n    //\n    // React Nodes\n    // http://facebook.github.io/react/docs/glossary.html\n    // ----------------------------------------------------------------------\n\n    type ReactText = string | number;\n    type ReactChild = ReactElement | ReactText;\n\n    interface ReactNodeArray extends Array<ReactNode> {}\n    type ReactFragment = {} | ReactNodeArray;\n    type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    function createFactory<T extends HTMLElement>(\n        type: keyof ReactHTML): HTMLFactory<T>;\n    function createFactory(\n ",
  "381a2a9d17d14e111f7d002c866debfcac6724e8:types/react/index.d.ts": "// Type definitions for React 16.9\n// Project: http://facebook.github.io/react/\n// Definitions by: Asana <https://asana.com>\n//                 AssureSign <http://www.assuresign.com>\n//                 Microsoft <https://microsoft.com>\n//                 John Reilly <https://github.com/johnnyreilly>\n//                 Benoit Benezech <https://github.com/bbenezech>\n//                 Patricio Zavolinsky <https://github.com/pzavolinsky>\n//                 Digiguru <https://github.com/digiguru>\n//                 Eric Anderson <https://github.com/ericanderson>\n//                 Dovydas Navickas <https://github.com/DovydasNavickas>\n//                 Josh Rutherford <https://github.com/theruther4d>\n//                 Guilherme Hübner <https://github.com/guilhermehubner>\n//                 Ferdy Budhidharma <https://github.com/ferdaber>\n//                 Johann Rakotoharisoa <https://github.com/jrakotoharisoa>\n//                 Olivier Pascal <https://github.com/pascaloliv>\n//                 Martin Hochel <https://github.com/hotell>\n//                 Frank Li <https://github.com/franklixuefei>\n//                 Jessica Franco <https://github.com/Jessidhia>\n//                 Saransh Kataria <https://github.com/saranshkataria>\n//                 Kanitkorn Sujautra <https://github.com/lukyth>\n//                 Sebastian Silbermann <https://github.com/eps1lon>\n//                 Kyle Scully <https://github.com/zieka>\n//                 Cong Zhang <https://github.com/dancerphil>\n//                 Dimitri Mitropoulos <https://github.com/dimitropoulos>\n//                 JongChan Choi <https://github.com/disjukr>\n//                 Victor Magalhães <https://github.com/vhfmag>\n//                 Dale Tan <https://github.com/hellatan>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.8\n\n// NOTE: Users of the `experimental` builds of React should add a reference\n// to 'react/experimental' in their project. See experimental.d.ts's top comment\n// for reference and documentation on how exactly to do it.\n\n/// <reference path=\"global.d.ts\" />\n\nimport * as CSS from 'csstype';\nimport * as PropTypes from 'prop-types';\n\ntype NativeAnimationEvent = AnimationEvent;\ntype NativeClipboardEvent = ClipboardEvent;\ntype NativeCompositionEvent = CompositionEvent;\ntype NativeDragEvent = DragEvent;\ntype NativeFocusEvent = FocusEvent;\ntype NativeKeyboardEvent = KeyboardEvent;\ntype NativeMouseEvent = MouseEvent;\ntype NativeTouchEvent = TouchEvent;\ntype NativePointerEvent = PointerEvent;\ntype NativeTransitionEvent = TransitionEvent;\ntype NativeUIEvent = UIEvent;\ntype NativeWheelEvent = WheelEvent;\ntype Booleanish = boolean | 'true' | 'false';\n\n/**\n * defined in scheduler/tracing\n */\ninterface SchedulerInteraction {\n    id: number;\n    name: string;\n    timestamp: number;\n}\n\n// tslint:disable-next-line:export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\n\n    type ElementType<P = any> =\n        {\n            [K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never\n        }[keyof JSX.IntrinsicElements] |\n        ComponentType<P>;\n    /**\n     * @deprecated Please use `ElementType`\n     */\n    type ReactType<P = any> = ElementType<P>;\n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\n\n    type JSXElementConstructor<P> =\n        | ((props: P) => ReactElement | null)\n        | (new (props: P) => Component<P, any>);\n\n    interface RefObject<T> {\n        readonly current: T | null;\n    }\n    type RefCallback<T> = { bivarianceHack(instance: T | null): void }[\"bivarianceHack\"];\n    type Ref<T> = RefCallback<T> | RefObject<T> | null;\n    type LegacyRef<T> = string | Ref<T>;\n    /**\n     * Gets the instance type for a React element. The instance will be different for various component types:\n     *\n     * - React class components will be the class instance. So if you had `class Foo extends React.Component<{}> {}`\n     *   and used `React.ElementRef<typeof Foo>` then the type would be the instance of `Foo`.\n     * - React stateless functional components do not have a backing instance and so `React.ElementRef<typeof Bar>`\n     *   (when `Bar` is `function Bar() {}`) will give you the `undefined` type.\n     * - JSX intrinsics like `div` will give you their DOM instance. For `React.ElementRef<'div'>` that would be\n     *   `HTMLDivElement`. For `React.ElementRef<'input'>` that would be `HTMLInputElement`.\n     * - React stateless functional components that forward a `ref` will give you the `ElementRef` of the forwarded\n     *   to component.\n     *\n     * `C` must be the type _of_ a React component so you need to use typeof as in React.ElementRef<typeof MyComponent>.\n     *\n     * @todo In Flow, this works a little different with forwarded refs and the `AbstractComponent` that\n     *       `React.forwardRef()` returns.\n     */\n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new (props: any): Component<any> }\n            | ((props: any, context?: any) => ReactElement | null)\n            | keyof JSX.IntrinsicElements\n    > =\n        // need to check first if `ref` is a valid prop for ts@3.0\n        // otherwise it will infer `{}` instead of `never`\n        \"ref\" extends keyof ComponentPropsWithRef<C>\n            ? NonNullable<ComponentPropsWithRef<C>[\"ref\"]> extends Ref<\n                infer Instance\n            >\n                ? Instance\n                : never\n            : never;\n\n    type ComponentState = any;\n\n    type Key = string | number;\n\n    /**\n     * @internal You shouldn't need to use this type since you never see these attributes\n     * inside your component or have to validate them.\n     */\n    interface Attributes {\n        key?: Key;\n    }\n    interface RefAttributes<T> extends Attributes {\n        ref?: Ref<T>;\n    }\n    interface ClassAttributes<T> extends Attributes {\n        ref?: LegacyRef<T>;\n    }\n\n    interface ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> {\n        type: T;\n        props: P;\n        key: Key | null;\n    }\n\n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, 'key' | 'ref'>>\n    > extends ReactElement<P, Exclude<T, number>> { }\n\n    /**\n     * @deprecated Please use `FunctionComponentElement`\n     */\n    type SFCElement<P> = FunctionComponentElement<P>;\n\n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n        ref?: 'ref' extends keyof P ? P extends { ref?: infer R } ? R : never : never;\n    }\n\n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n        ref?: LegacyRef<T>;\n    }\n\n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element> extends ReactElement<P, string> {\n        ref: LegacyRef<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    // tslint:disable-next-line:no-empty-interface\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> { }\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: keyof ReactHTML;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: keyof ReactSVG;\n    }\n\n    interface ReactPortal extends ReactElement {\n        key: Key | null;\n        children: ReactNode;\n    }\n\n    //\n    // Factories\n    // ----------------------------------------------------------------------\n\n    type Factory<P> = (props?: Attributes & P, ...children: ReactNode[]) => ReactElement<P>;\n\n    /**\n     * @deprecated Please use `FunctionComponentFactory`\n     */\n    type SFCFactory<P> = FunctionComponentFactory<P>;\n\n    type FunctionComponentFactory<P> = (props?: Attributes & P, ...children: ReactNode[]) => FunctionComponentElement<P>;\n\n    type ComponentFactory<P, T extends Component<P, ComponentState>> =\n        (props?: ClassAttributes<T> & P, ...children: ReactNode[]) => CElement<P, T>;\n\n    type CFactory<P, T extends Component<P, ComponentState>> = ComponentFactory<P, T>;\n    type ClassicFactory<P> = CFactory<P, ClassicComponent<P, ComponentState>>;\n\n    type DOMFactory<P extends DOMAttributes<T>, T extends Element> =\n        (props?: ClassAttributes<T> & P | null, ...children: ReactNode[]) => DOMElement<P, T>;\n\n    // tslint:disable-next-line:no-empty-interface\n    interface HTMLFactory<T extends HTMLElement> extends DetailedHTMLFactory<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedHTMLFactory<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMFactory<P, T> {\n        (props?: ClassAttributes<T> & P | null, ...children: ReactNode[]): DetailedReactHTMLElement<P, T>;\n    }\n\n    interface SVGFactory extends DOMFactory<SVGAttributes<SVGElement>, SVGElement> {\n        (props?: ClassAttributes<SVGElement> & SVGAttributes<SVGElement> | null, ...children: ReactNode[]): ReactSVGElement;\n    }\n\n    //\n    // React Nodes\n    // http://facebook.github.io/react/docs/glossary.html\n    // ----------------------------------------------------------------------\n\n    type ReactText = string | number;\n    type ReactChild = ReactElement | ReactText;\n\n    interface ReactNodeArray extends Array<ReactNode> {}\n    type ReactFragment = {} | ReactNodeArray;\n    type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    function createFactory<T extends HTMLElement>(\n        type: keyof ReactHTML): HTMLFactory<T>;\n    function createFactory(\n "
}
