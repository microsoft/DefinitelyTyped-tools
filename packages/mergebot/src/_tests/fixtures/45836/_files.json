{
  "master:types/prosemirror-commands/index.d.ts": "// Type definitions for prosemirror-commands 1.0\n// Project: https://github.com/ProseMirror/prosemirror-commands\n// Definitions by: Bradley Ayers <https://github.com/bradleyayers>\n//                 David Hahn <https://github.com/davidka>\n//                 Tim Baumann <https://github.com/timjb>\n//                 Patrick Simmelbauer <https://github.com/patsimm>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\nimport { MarkType, Node as ProsemirrorNode, NodeType, Schema } from 'prosemirror-model';\nimport { EditorState, Transaction } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\n\nexport interface Command<S extends Schema = any> {\n  (\n    state: EditorState<S>,\n    dispatch: (tr: Transaction<S>) => void,\n    view: EditorView<S>\n  ): boolean;\n}\n\nexport interface Keymap<S extends Schema = any> {\n  [key: string]: Command<S>;\n}\n\n/**\n * Delete the selection, if there is one.\n */\nexport function deleteSelection<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If the selection is empty and at the start of a textblock, try to\n * reduce the distance between that block and the one before itâ€”if\n * there's a block directly before it that can be joined, join them.\n * If not, try to move the selected block closer to the next one in\n * the document structure by lifting it out of its parent or moving it\n * into a parent of the previous block. Will use the view for accurate\n * (bidi-aware) start-of-textblock detection if given.\n */\nexport function joinBackward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * When the selection is empty and at the start of a textblock, select\n * the node before that textblock, if possible. This is intended to be\n * bound to keys like backspace, after\n * [`joinBackward`](#commands.joinBackward) or other deleting\n * commands, as a fall-back behavior when the schema doesn't allow\n * deletion at the selected point.\n */\nexport function selectNodeBackward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * If the selection is empty and the cursor is at the end of a\n * textblock, try to reduce or remove the boundary between that block\n * and the one after it, either by joining them or by moving the other\n * block closer to this one in the tree structure. Will use the view\n * for accurate start-of-textblock detection if given.\n */\nexport function joinForward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * When the selection is empty and at the end of a textblock, select\n * the node coming after that textblock, if possible. This is intended\n * to be bound to keys like delete, after\n * [`joinForward`](#commands.joinForward) and similar deleting\n * commands, to provide a fall-back behavior when the schema doesn't\n * allow deletion at the selected point.\n */\nexport function selectNodeForward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * Join the selected block or, if there is a text selection, the\n * closest ancestor block of the selection that can be joined, with\n * the sibling above it.\n */\nexport function joinUp<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Join the selected block, or the closest ancestor of the selection\n * that can be joined, with the sibling after it.\n */\nexport function joinDown<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Lift the selected block, or the closest ancestor block of the\n * selection that can be lifted, out of its parent node.\n */\nexport function lift<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If the selection is in a node whose type has a truthy\n * [`code`](#model.NodeSpec.code) property in its spec, replace the\n * selection with a newline character.\n */\nexport function newlineInCode<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * When the selection is in a node with a truthy\n * [`code`](#model.NodeSpec.code) property in its spec, create a\n * default block after the code block, and move the cursor there.\n */\nexport function exitCode<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If a block node is selected, create an empty paragraph before (if\n * it is its parent's first child) or after it.\n */\nexport function createParagraphNear<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If the cursor is in an empty textblock that can be lifted, lift the\n * block.\n */\nexport function liftEmptyBlock<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Split the parent block of the selection. If the selection is a text\n * selection, also delete its content.\n */\nexport function splitBlock<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Acts like [`splitBlock`](#commands.splitBlock), but without\n * resetting the set of active marks at the cursor.\n */\nexport function splitBlockKeepMarks<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Move the selection to the node wrapping the current selection, if\n * any. (Will not select the document node.)\n */\nexport function selectParentNode<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Select the whole document.\n */\nexport function selectAll<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Wrap the selection in a node of the given type with the given\n * attributes.\n */\nexport function wrapIn<S extends Schema = any>(\n  nodeType: NodeType<S>,\n  attrs?: { [key: string]: any }\n): (state: EditorState<S>, dispatch?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Returns a command that tries to set the textblock around the\n * selection to the given node type with the given attributes.\n */\nexport function setBlockType<S extends Schema = any>(\n  nodeType: NodeType<S>,\n  attrs?: { [key: string]: any }\n): (state: EditorState<S>, dispatch?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Create a command function that toggles the given mark with the\n * given attributes. Will return `false` when the current selection\n * doesn't support that mark. This will remove the mark if any marks\n * of that type exist in the selection, or add it otherwise. If the\n * selection is empty, this applies to the [stored\n * marks](#state.EditorState.storedMarks) instead of a range of the\n * document.\n */\nexport function toggleMark<S extends Schema = any>(\n  markType: MarkType<S>,\n  attrs?: { [key: string]: any }\n): (state: EditorState<S>, dispatch?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Wrap a command so that, when it produces a transform that causes\n * two joinable nodes to end up next to each other, those are joined.\n * Nodes are considered joinable when they are of the same type and\n * when the `isJoinable` predicate returns true for them or, if an\n * array of strings was passed, if their node type name is in that\n * array.\n */\nexport function autoJoin<S extends Schema = any>(\n  command: (state: EditorState<S>, p1?: (tr: Transaction<S>) => void) => boolean,\n  isJoinable: ((before: ProsemirrorNode<S>, after: ProsemirrorNode<S>) => boolean) | string[]\n): (state: EditorState<S>, p1?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Combine a number of command functions into a single function (which\n * calls them one by one until one returns true).\n */\nexport function chainCommands<S extends Schema = any>(\n  ...commands: Array<\n    (p1: EditorState<S>, p2?: (tr: Transaction<S>) => void, p3?: EditorView<S>) => boolean\n    >\n): (p1: EditorState<S>, p2?: (tr: Transaction<S>) => void, p3?: EditorView<S>) => boolean;\n/**\n * A basic keymap containing bindings not specific to any schema.\n * Binds the following keys (when multiple commands are listed, they\n * are chained with [`chainCommands`](#commands.chainCommands)):\n *\n * * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n * * **Mod-Enter** to `exitCode`\n * * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n * * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n * * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n * * **Mod-a** to `selectAll`\n */\nexport let pcBaseKeymap: Keymap;\n/**\n * A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n * **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n * **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n * Ctrl-Delete.\n */\nexport let macBaseKeymap: Keymap;\n/**\n * Depending on the detected platform, this will hold\n * [`pcBasekeymap`](#commands.pcBaseKeymap) or\n * [`macBaseKeymap`](#commands.macBaseKeymap).\n */\nexport let baseKeymap: Keymap;\n",
  "6c7735e2b8f39640cb73e40ae04cb6642a8ab2cd:types/prosemirror-commands/index.d.ts": "// Type definitions for prosemirror-commands 1.0\n// Project: https://github.com/ProseMirror/prosemirror-commands\n// Definitions by: Bradley Ayers <https://github.com/bradleyayers>\n//                 David Hahn <https://github.com/davidka>\n//                 Tim Baumann <https://github.com/timjb>\n//                 Patrick Simmelbauer <https://github.com/patsimm>\n//                 Mike Morearty <https://github.com/mmorearty>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 3.0\n\nimport { MarkType, Node as ProsemirrorNode, NodeType, Schema } from 'prosemirror-model';\nimport { EditorState, Transaction } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\n\nexport interface Command<S extends Schema = any> {\n  (\n    state: EditorState<S>,\n    dispatch: (tr: Transaction<S>) => void,\n    view: EditorView<S>\n  ): boolean;\n}\n\nexport interface Keymap<S extends Schema = any> {\n  [key: string]: Command<S>;\n}\n\n/**\n * Delete the selection, if there is one.\n */\nexport function deleteSelection<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If the selection is empty and at the start of a textblock, try to\n * reduce the distance between that block and the one before itâ€”if\n * there's a block directly before it that can be joined, join them.\n * If not, try to move the selected block closer to the next one in\n * the document structure by lifting it out of its parent or moving it\n * into a parent of the previous block. Will use the view for accurate\n * (bidi-aware) start-of-textblock detection if given.\n */\nexport function joinBackward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * When the selection is empty and at the start of a textblock, select\n * the node before that textblock, if possible. This is intended to be\n * bound to keys like backspace, after\n * [`joinBackward`](#commands.joinBackward) or other deleting\n * commands, as a fall-back behavior when the schema doesn't allow\n * deletion at the selected point.\n */\nexport function selectNodeBackward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * If the selection is empty and the cursor is at the end of a\n * textblock, try to reduce or remove the boundary between that block\n * and the one after it, either by joining them or by moving the other\n * block closer to this one in the tree structure. Will use the view\n * for accurate start-of-textblock detection if given.\n */\nexport function joinForward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * When the selection is empty and at the end of a textblock, select\n * the node coming after that textblock, if possible. This is intended\n * to be bound to keys like delete, after\n * [`joinForward`](#commands.joinForward) and similar deleting\n * commands, to provide a fall-back behavior when the schema doesn't\n * allow deletion at the selected point.\n */\nexport function selectNodeForward<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void,\n  view?: EditorView<S>\n): boolean;\n/**\n * Join the selected block or, if there is a text selection, the\n * closest ancestor block of the selection that can be joined, with\n * the sibling above it.\n */\nexport function joinUp<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Join the selected block, or the closest ancestor of the selection\n * that can be joined, with the sibling after it.\n */\nexport function joinDown<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Lift the selected block, or the closest ancestor block of the\n * selection that can be lifted, out of its parent node.\n */\nexport function lift<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If the selection is in a node whose type has a truthy\n * [`code`](#model.NodeSpec.code) property in its spec, replace the\n * selection with a newline character.\n */\nexport function newlineInCode<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * When the selection is in a node with a truthy\n * [`code`](#model.NodeSpec.code) property in its spec, create a\n * default block after the code block, and move the cursor there.\n */\nexport function exitCode<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If a block node is selected, create an empty paragraph before (if\n * it is its parent's first child) or after it.\n */\nexport function createParagraphNear<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * If the cursor is in an empty textblock that can be lifted, lift the\n * block.\n */\nexport function liftEmptyBlock<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Split the parent block of the selection. If the selection is a text\n * selection, also delete its content.\n */\nexport function splitBlock<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Acts like [`splitBlock`](#commands.splitBlock), but without\n * resetting the set of active marks at the cursor.\n */\nexport function splitBlockKeepMarks<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Move the selection to the node wrapping the current selection, if\n * any. (Will not select the document node.)\n */\nexport function selectParentNode<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Select the whole document.\n */\nexport function selectAll<S extends Schema = any>(\n  state: EditorState<S>,\n  dispatch?: (tr: Transaction<S>) => void\n): boolean;\n/**\n * Wrap the selection in a node of the given type with the given\n * attributes.\n */\nexport function wrapIn<S extends Schema = any>(\n  nodeType: NodeType<S>,\n  attrs?: { [key: string]: any }\n): (state: EditorState<S>, dispatch?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Returns a command that tries to set the textblock around the\n * selection to the given node type with the given attributes.\n */\nexport function setBlockType<S extends Schema = any>(\n  nodeType: NodeType<S>,\n  attrs?: { [key: string]: any }\n): (state: EditorState<S>, dispatch?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Create a command function that toggles the given mark with the\n * given attributes. Will return `false` when the current selection\n * doesn't support that mark. This will remove the mark if any marks\n * of that type exist in the selection, or add it otherwise. If the\n * selection is empty, this applies to the [stored\n * marks](#state.EditorState.storedMarks) instead of a range of the\n * document.\n */\nexport function toggleMark<S extends Schema = any>(\n  markType: MarkType<S>,\n  attrs?: { [key: string]: any }\n): (state: EditorState<S>, dispatch?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Wrap a command so that, when it produces a transform that causes\n * two joinable nodes to end up next to each other, those are joined.\n * Nodes are considered joinable when they are of the same type and\n * when the `isJoinable` predicate returns true for them or, if an\n * array of strings was passed, if their node type name is in that\n * array.\n */\nexport function autoJoin<S extends Schema = any>(\n  command: (state: EditorState<S>, p1?: (tr: Transaction<S>) => void) => boolean,\n  isJoinable: ((before: ProsemirrorNode<S>, after: ProsemirrorNode<S>) => boolean) | string[]\n): (state: EditorState<S>, p1?: (tr: Transaction<S>) => void) => boolean;\n/**\n * Combine a number of command functions into a single function (which\n * calls them one by one until one returns true).\n */\nexport function chainCommands<S extends Schema = any>(\n  ...commands: Array<\n    (p1: EditorState<S>, p2?: (tr: Transaction<S>) => void, p3?: EditorView<S>) => boolean\n    >\n): (p1: EditorState<S>, p2?: (tr: Transaction<S>) => void, p3?: EditorView<S>) => boolean;\n/**\n * A basic keymap containing bindings not specific to any schema.\n * Binds the following keys (when multiple commands are listed, they\n * are chained with [`chainCommands`](#commands.chainCommands)):\n *\n * * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n * * **Mod-Enter** to `exitCode`\n * * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n * * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n * * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n * * **Mod-a** to `selectAll`\n */\nexport let pcBaseKeymap: Keymap;\n/**\n * A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n * **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n * **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n * Ctrl-Delete.\n */\nexport let macBaseKeymap: Keymap;\n/**\n * Depending on the detected platform, this will hold\n * [`pcBasekeymap`](#commands.pcBaseKeymap) or\n * [`macBaseKeymap`](#commands.macBaseKeymap).\n */\nexport let baseKeymap: Keymap;\n",
  "master:types/prosemirror-keymap/index.d.ts": "// Type definitions for prosemirror-keymap 1.0\n// Project: https://github.com/ProseMirror/prosemirror-keymap\n// Definitions by: Bradley Ayers <https://github.com/bradleyayers>\n//                 David Hahn <https://github.com/davidka>\n//                 Tim Baumann <https://github.com/timjb>\n//                 Patrick Simmelbauer <https://github.com/patsimm>\n//                 Mike Morearty <https://github.com/mmorearty>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 3.0\n\nimport { Keymap } from 'prosemirror-commands';\nimport { Schema } from 'prosemirror-model';\nimport { Plugin } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\n\n/**\n * Create a keymap plugin for the given set of bindings.\n *\n * Bindings should map key names to [command](#commands)-style\n * functions, which will be called with `(EditorState, dispatch,\n * EditorView)` arguments, and should return true when they've handled\n * the key. Note that the view argument isn't part of the command\n * protocol, but can be used as an escape hatch if a binding needs to\n * directly interact with the UI.\n *\n * Key names may be strings like `\"Shift-Ctrl-Enter\"`â€”a key\n * identifier prefixed with zero or more modifiers. Key identifiers\n * are based on the strings that can appear in\n * [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n * Use lowercase letters to refer to letter keys (or uppercase letters\n * if you want shift to be held). You may use `\"Space\"` as an alias\n * for the `\" \"` name.\n *\n * Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n * `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n * `Meta-`) are recognized. For characters that are created by holding\n * shift, the `Shift-` prefix is implied, and should not be added\n * explicitly.\n *\n * You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n * other platforms.\n *\n * You can add multiple keymap plugins to an editor. The order in\n * which they appear determines their precedence (the ones early in\n * the array get to dispatch first).\n */\nexport function keymap<S extends Schema = any>(bindings: Keymap<S>): Plugin;\n\n/**\n * Given a set of bindings (using the same format as\n * [`keymap`](#keymap.keymap), return a [keydown\n * handler](#view.EditorProps.handleKeyDown) handles them.\n */\nexport function keydownHandler<S extends Schema = any>(\n  bindings: Keymap<S>,\n): (view: EditorView, event: KeyboardEvent) => boolean;\n",
  "6c7735e2b8f39640cb73e40ae04cb6642a8ab2cd:types/prosemirror-keymap/index.d.ts": "// Type definitions for prosemirror-keymap 1.0\n// Project: https://github.com/ProseMirror/prosemirror-keymap\n// Definitions by: Bradley Ayers <https://github.com/bradleyayers>\n//                 David Hahn <https://github.com/davidka>\n//                 Tim Baumann <https://github.com/timjb>\n//                 Patrick Simmelbauer <https://github.com/patsimm>\n//                 Mike Morearty <https://github.com/mmorearty>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 3.0\n\nimport { Keymap } from 'prosemirror-commands';\nimport { Schema } from 'prosemirror-model';\nimport { Plugin } from 'prosemirror-state';\nimport { EditorView } from 'prosemirror-view';\n\n/**\n * Create a keymap plugin for the given set of bindings.\n *\n * Bindings should map key names to [command](#commands)-style\n * functions, which will be called with `(EditorState, dispatch,\n * EditorView)` arguments, and should return true when they've handled\n * the key. Note that the view argument isn't part of the command\n * protocol, but can be used as an escape hatch if a binding needs to\n * directly interact with the UI.\n *\n * Key names may be strings like `\"Shift-Ctrl-Enter\"`â€”a key\n * identifier prefixed with zero or more modifiers. Key identifiers\n * are based on the strings that can appear in\n * [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\n * Use lowercase letters to refer to letter keys (or uppercase letters\n * if you want shift to be held). You may use `\"Space\"` as an alias\n * for the `\" \"` name.\n *\n * Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n * `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n * `Meta-`) are recognized. For characters that are created by holding\n * shift, the `Shift-` prefix is implied, and should not be added\n * explicitly.\n *\n * You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\n * other platforms.\n *\n * You can add multiple keymap plugins to an editor. The order in\n * which they appear determines their precedence (the ones early in\n * the array get to dispatch first).\n */\nexport function keymap<S extends Schema = any>(bindings: Keymap<S>): Plugin;\n\n/**\n * Given a set of bindings (using the same format as\n * [`keymap`](#keymap.keymap), return a [keydown\n * handler](#view.EditorProps.handleKeyDown) handles them.\n */\nexport function keydownHandler<S extends Schema = any>(\n  bindings: Keymap<S>,\n): (view: EditorView, event: KeyboardEvent) => boolean;\n"
}
