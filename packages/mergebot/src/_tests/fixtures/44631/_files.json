{
  "master:types/kefir/index.d.ts": "// Type definitions for Kefir 3.8.1\n// Project: http://rpominov.github.io/kefir/\n// Definitions by: Aya Morisawa <https://github.com/AyaMorisawa>\n//                 Piotr Hitori Bosak <https://github.com/HitoriSensei>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.7\n\n/// <reference types=\"node\" />\n\nexport type ValueOfAnObservable<T extends Observable<any, any>> = T[''];\n\nexport interface Subscription {\n    unsubscribe(): void;\n    readonly closed: boolean;\n}\n\nexport interface Observer<T, S> {\n    value?: (value: T) => void;\n    error?: (error: S) => void;\n    end?: () => void;\n}\n\ninterface ESObserver<T, S> {\n  start?: Function,\n  next?: (value: T) => any,\n  error?: (error: S) => any,\n  complete?: () => any,\n}\n\ninterface ESObservable<T, S> {\n  subscribe(callbacks: ESObserver<T, S>): { unsubscribe(): void };\n}\n\nexport class Observable<T, S> {\n    '': T; // TypeScript hack to enable value unwrapping for combine/flatMap\n\n    toProperty(): Property<T, S>;\n    toProperty<T2>(getCurrent?: () => T2): Property<T | T2, S>;\n    changes(): Observable<T, S>;\n\n    // Subscribe / add side effects\n    onValue(callback: (value: T) => void): this;\n    offValue(callback: (value: T) => void): this;\n    onError(callback: (error: S) => void): this;\n    offError(callback: (error: S) => void): this;\n    onEnd(callback: () => void): this;\n    offEnd(callback: () => void): this;\n    onAny(callback: (event: Event<T, S>) => void): this;\n    offAny(callback: (event: Event<T, S>) => void): this;\n    log(name?: string): this;\n    spy(name?: string): this;\n    offLog(name?: string): this;\n    offSpy(name?: string): this;\n    flatten<U>(transformer?: (value: T) => U[]): Stream<U, S>;\n    toPromise(): Promise<T>;\n    toPromise<W extends PromiseLike<T>>(PromiseConstructor: () => W): W;\n    toESObservable(): ESObservable<T, S>;\n    // This method is designed to replace all other methods for subscribing\n    observe(params: Observer<T, S>): Subscription;\n    observe(\n        onValue?: (value: T) => void,\n        onError?: (error: S) => void,\n        onEnd?: () => void\n    ): Subscription;\n    setName(source: Observable<any, any>, selfName: string): this;\n    setName(selfName: string): this;\n\n    thru<R>(cb: (obs: Observable<T, S>) => R): R;\n    // Modify an stream\n    map<U>(fn: (value: T) => U): Observable<U, S>;\n    filter<U extends T>(fn: (value: T) => value is U): Observable<U, S>\n    filter(predicate?: (value: T) => boolean): Observable<T, S>;\n    take(n: number): Observable<T, S>;\n    takeWhile(predicate?: (value: T) => boolean): Observable<T, S>;\n    last(): Observable<T, S>;\n    skip(n: number): Observable<T, S>;\n    skipWhile(predicate?: (value: T) => boolean): Observable<T, S>;\n    skipDuplicates(comparator?: (a: T, b: T) => boolean): Observable<T, S>;\n    diff(fn?: (prev: T, next: T) => T, seed?: T): Observable<T, S>;\n    scan<W>(fn: (prev: T | W, next: T) => W): Observable<W, S>;\n    scan<W>(fn: (prev: W, next: T) => W, seed: W): Observable<W, S>;\n    delay(wait: number): Observable<T, S>;\n    throttle(wait: number, options?: { leading?: boolean, trailing?: boolean }): Observable<T, S>;\n    debounce(wait: number, options?: { immediate: boolean }): Observable<T, S>;\n    valuesToErrors(): Observable<never, S | T>;\n    valuesToErrors<U>(handler: (value: T) => { convert: boolean, error: U }): Observable<never, S | U>;\n    errorsToValues<U>(handler?: (error: S) => { convert: boolean, value: U }): Observable<T | U, never>;\n    mapErrors<U>(fn: (error: S) => U): Observable<T, U>;\n    filterErrors(predicate?: (error: S) => boolean): Observable<T, S>;\n    endOnError(): Observable<T, S>;\n    takeErrors(n: number): Observable<T, S>;\n    ignoreValues(): Observable<never, S>;\n    ignoreErrors(): Observable<T, never>;\n    ignoreEnd(): Observable<T, S>;\n    beforeEnd<U>(fn: () => U): Observable<T | U, S>;\n    slidingWindow(max: number, mix?: number): Observable<T[], S>;\n    bufferWhile(predicate: (value: T) => boolean): Observable<T[], S>;\n    bufferWithCount(count: number, options?: { flushOnEnd: boolean }): Observable<T[], S>;\n    bufferWithTimeOrCount(interval: number, count: number, options?: { flushOnEnd: boolean }): Observable<T[], S>;\n    transduce<U>(transducer: any): Observable<U, S>;\n    withHandler<U, V>(handler: (emitter: Emitter<U, S>, event: Event<T, S>) => void): Observable<U, S>;\n    // Combine streams\n    combine<U, V, W>(otherObs: Observable<U, V>, combinator?: (value: T, ...values: U[]) => W): Observable<W, S | V>;\n    zip<U, V, W>(otherObs: Observable<U, V>, combinator?: (value: T, ...values: U[]) => W): Observable<W, S | V>;\n    merge<U, V>(otherObs: Observable<U, V>): Observable<T | U, S | V>;\n    concat<U, V>(otherObs: Observable<U, V>): Observable<T | U, S | V>;\n    flatMap<U, V>(transform: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMap<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapLatest<U, V>(fn: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMapLatest<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapFirst<U, V>(fn: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMapFirst<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapConcat<U, V>(fn: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMapConcat<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapConcurLimit<U, V>(fn: (value: T) => Observable<U, V>, limit: number): Observable<U, V | S>;\n    flatMapErrors<U, V>(transform: (error: S) => Observable<U, V>): Observable<U | T, V>;\n    // Combine two streams\n    filterBy<U>(otherObs: Observable<boolean, U>): Observable<T, S>;\n    sampledBy(otherObs: Observable<any, any>): Observable<T, S>;\n    sampledBy<U, W>(otherObs: Observable<U, any>, combinator: (a: T, b: U) => W): Observable<W, S>;\n    skipUntilBy<U, V>(otherObs: Observable<U, V>): Observable<U, V>;\n    takeUntilBy<U, V>(otherObs: Observable<U, V>): Observable<T, S>;\n    bufferBy<U, V>(otherObs: Observable<U, V>, options?: { flushOnEnd: boolean }): Observable<T[], S>;\n    bufferWhileBy<U>(otherObs: Observable<boolean, U>, options?: { flushOnEnd?: boolean, flushOnChange?: boolean }): Observable<T[], S>;\n    awaiting<U, V>(otherObs: Observable<U, V>): Observable<boolean, S>;\n}\n\nexport class Stream<T, S> extends Observable<T, S> {\n\n}\n\nexport class Property<T, S> extends Observable<T, S> {\n\n}\n\nexport class Pool<T, S> extends Observable<T, S> {\n    plug(obs: Observable<T, S>): this;\n    unplug(obs: Observable<T, S>): this;\n}\n\nexport type Event<V,E> =\n    { type: 'value', value: V } |\n    { type: 'error', value: E } |\n    { type: 'end', value: void };\n\nexport interface Emitter<V, E> {\n    value(value: V): boolean;\n    event(event: Event<V, E>): boolean;\n    error(e: E): boolean;\n    end(): void;\n\n    // Deprecated methods\n    emit(value: V): boolean;\n    emitEvent(event: Event<V, E>): boolean;\n}\n\n// Create a stream\nexport function never(): Stream<never, never>;\nexport function later<T>(wait: number, value: T): Stream<T, never>;\nexport function interval<T>(interval: number, value: T): Stream<T, never>;\nexport function sequentially<T>(interval: number, values: T[]): Stream<T, never>;\nexport function fromPoll<T>(interval: number, fn: () => T): Stream<T, never>;\nexport function withInterval<T, S>(interval: number, handler: (emitter: Emitter<T, S>) => void): Stream<T, S>;\nexport function fromCallback<T>(fn: (callback: (value: T) => void) => void): Stream<T, never>;\nexport function fromNodeCallback<T, S>(fn: (callback: (error: S | null, result: T) => void) => void): Stream<T, S>;\nexport function fromEvents<T, S>(target: EventTarget | NodeJS.EventEmitter | { on: Function, off: Function }, eventName: string, transform?: (value: T) => S): Stream<T, S>;\nexport function stream<T, S>(subscribe: (emitter: Emitter<T, S>) => Function | void): Stream<T, S>;\nexport function fromESObservable<T, S>(observable: any): Stream<T, S>\n\n// Create a property\nexport function constant<T>(value: T): Property<T, never>;\nexport function constantError<T>(error: T): Property<never, T>;\nexport function fromPromise<T, S>(promise: Promise<T>): Property<T, S>;\n// Combine observables\nexport function combine<T, S, U>(obss: Observable<T, S>[], passiveObss: Observable<T, S>[], combinator?: (...values: T[]) => U): Stream<U, S>;\nexport function combine<T, S, U>(obss: Observable<T, S>[], combinator: (...values: T[]) => U): Stream<U, S>;\nexport function combine<T extends { [name: string]: Observable<any, any> }>(obss: T): Stream<{ [P in keyof T]: ValueOfAnObservable<T[P]> }, any>;\nexport function combine<T extends { [name: string]: Observable<any, any> }, K extends { [name: string]: Observable<any, any> }>(obss: T, passiveObss: K): Stream<{ [P in keyof T]: ValueOfAnObservable<T[P]> } & { [P in keyof K]: ValueOfAnObservable<K[P]> }, any>;\nexport function combine<T extends [Observable<any, any>], P extends keyof T>(obss: T): Stream<[ValueOfAnObservable<T[0]>], any>;\nexport function combine<T extends [Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>]>(obss: T): Stream<[ValueOfAnObservable<T[0]>, ValueOfAnObservable<T[1]>, ValueOfAnObservable<T[2]>, ValueOfAnObservable<T[3]>, ValueOfAnObservable<T[4]>, ValueOfAnObservable<T[5]>, ValueOfAnObservable<T[6]>, ValueOfAnObservable<T[7]>], any>;\nexport function combine<T extends [Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>]>(obss: T): Stream<[ValueOfAnObservable<T[0]>, ValueOfAnObservable<T[1]>, ValueOfAnObservable<T[2]>, ValueOfAnObservable<T[3]>, ValueOfAnObservable<T[4]>, ValueOfAnObservable<T[5]>, ValueOfAnObservable<T[6]>], any>;\nexport function combine<T extends [Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>]>(obss: T): Stream<[ValueOfAnObservable<T[0]>, ValueOfAnObservable<T[1]>, ValueOfAnObservable<T[2]>, ValueOfAnObservable<T[3]>, ValueOfAnObs",
  "96d6582f60431d273c179dcf6816426b4f1e37ac:types/kefir/index.d.ts": "// Type definitions for Kefir 3.8.1\n// Project: http://rpominov.github.io/kefir/\n// Definitions by: Aya Morisawa <https://github.com/AyaMorisawa>\n//                 Piotr Hitori Bosak <https://github.com/HitoriSensei>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.7\n\n/// <reference types=\"node\" />\n\nexport type ValueOfAnObservable<T extends Observable<any, any>> = T[''];\n\nexport interface Subscription {\n    unsubscribe(): void;\n    readonly closed: boolean;\n}\n\nexport interface Observer<T, S> {\n    value?: (value: T) => void;\n    error?: (error: S) => void;\n    end?: () => void;\n}\n\ninterface ESObserver<T, S> {\n  start?: Function,\n  next?: (value: T) => any,\n  error?: (error: S) => any,\n  complete?: () => any,\n}\n\ninterface ESObservable<T, S> {\n  subscribe(callbacks: ESObserver<T, S>): { unsubscribe(): void };\n}\n\nexport class Observable<T, S> {\n    '': T; // TypeScript hack to enable value unwrapping for combine/flatMap\n\n    toProperty(): Property<T, S>;\n    toProperty<T2>(getCurrent?: () => T2): Property<T | T2, S>;\n    changes(): Observable<T, S>;\n\n    // Subscribe / add side effects\n    onValue(callback: (value: T) => void): this;\n    offValue(callback: (value: T) => void): this;\n    onError(callback: (error: S) => void): this;\n    offError(callback: (error: S) => void): this;\n    onEnd(callback: () => void): this;\n    offEnd(callback: () => void): this;\n    onAny(callback: (event: Event<T, S>) => void): this;\n    offAny(callback: (event: Event<T, S>) => void): this;\n    log(name?: string): this;\n    spy(name?: string): this;\n    offLog(name?: string): this;\n    offSpy(name?: string): this;\n    flatten<U>(transformer?: (value: T) => U[]): Stream<U, S>;\n    toPromise(): Promise<T>;\n    toPromise<W extends PromiseLike<T>>(PromiseConstructor: () => W): W;\n    toESObservable(): ESObservable<T, S>;\n    // This method is designed to replace all other methods for subscribing\n    observe(params: Observer<T, S>): Subscription;\n    observe(\n        onValue?: (value: T) => void,\n        onError?: (error: S) => void,\n        onEnd?: () => void\n    ): Subscription;\n    setName(source: Observable<any, any>, selfName: string): this;\n    setName(selfName: string): this;\n\n    thru<R>(cb: (obs: Observable<T, S>) => R): R;\n    // Modify an stream\n    map<U>(fn: (value: T) => U): Observable<U, S>;\n    filter<U extends T>(fn: (value: T) => value is U): Observable<U, S>\n    filter(predicate?: (value: T) => boolean): Observable<T, S>;\n    take(n: number): Observable<T, S>;\n    takeWhile(predicate?: (value: T) => boolean): Observable<T, S>;\n    last(): Observable<T, S>;\n    skip(n: number): Observable<T, S>;\n    skipWhile(predicate?: (value: T) => boolean): Observable<T, S>;\n    skipDuplicates(comparator?: (a: T, b: T) => boolean): Observable<T, S>;\n    diff(fn?: (prev: T, next: T) => T, seed?: T): Observable<T, S>;\n    scan<W>(fn: (prev: T | W, next: T) => W): Observable<W, S>;\n    scan<W>(fn: (prev: W, next: T) => W, seed: W): Observable<W, S>;\n    delay(wait: number): Observable<T, S>;\n    throttle(wait: number, options?: { leading?: boolean, trailing?: boolean }): Observable<T, S>;\n    debounce(wait: number, options?: { immediate: boolean }): Observable<T, S>;\n    valuesToErrors(): Observable<never, S | T>;\n    valuesToErrors<U>(handler: (value: T) => { convert: boolean, error: U }): Observable<never, S | U>;\n    errorsToValues<U>(handler?: (error: S) => { convert: boolean, value: U }): Observable<T | U, never>;\n    mapErrors<U>(fn: (error: S) => U): Observable<T, U>;\n    filterErrors(predicate?: (error: S) => boolean): Observable<T, S>;\n    endOnError(): Observable<T, S>;\n    takeErrors(n: number): Observable<T, S>;\n    ignoreValues(): Observable<never, S>;\n    ignoreErrors(): Observable<T, never>;\n    ignoreEnd(): Observable<T, S>;\n    beforeEnd<U>(fn: () => U): Observable<T | U, S>;\n    slidingWindow(max: number, mix?: number): Observable<T[], S>;\n    bufferWhile(predicate: (value: T) => boolean): Observable<T[], S>;\n    bufferWithCount(count: number, options?: { flushOnEnd: boolean }): Observable<T[], S>;\n    bufferWithTimeOrCount(interval: number, count: number, options?: { flushOnEnd: boolean }): Observable<T[], S>;\n    transduce<U>(transducer: any): Observable<U, S>;\n    withHandler<U, V>(handler: (emitter: Emitter<U, S>, event: Event<T, S>) => void): Observable<U, S>;\n    // Combine streams\n    combine<U, V, W>(otherObs: Observable<U, V>, combinator?: (value: T, ...values: U[]) => W): Observable<W, S | V>;\n    zip<U, V, W>(otherObs: Observable<U, V>, combinator?: (value: T, ...values: U[]) => W): Observable<W, S | V>;\n    merge<U, V>(otherObs: Observable<U, V>): Observable<T | U, S | V>;\n    concat<U, V>(otherObs: Observable<U, V>): Observable<T | U, S | V>;\n    flatMap<U, V>(transform: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMap<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapLatest<U, V>(fn: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMapLatest<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapFirst<U, V>(fn: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMapFirst<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapConcat<U, V>(fn: (value: T) => Observable<U, V>): Observable<U, V | S>;\n    flatMapConcat<X extends T & Property<T, any>>(): Observable<ValueOfAnObservable<X>, any>;\n    flatMapConcurLimit<U, V>(fn: (value: T) => Observable<U, V>, limit: number): Observable<U, V | S>;\n    flatMapErrors<U, V>(transform: (error: S) => Observable<U, V>): Observable<U | T, V>;\n    // Combine two streams\n    filterBy<U>(otherObs: Observable<boolean, U>): Observable<T, S>;\n    sampledBy(otherObs: Observable<any, any>): Observable<T, S>;\n    sampledBy<U, W>(otherObs: Observable<U, any>, combinator: (a: T, b: U) => W): Observable<W, S>;\n    skipUntilBy<U, V>(otherObs: Observable<U, V>): Observable<U, V>;\n    takeUntilBy<U, V>(otherObs: Observable<U, V>): Observable<T, S>;\n    bufferBy<U, V>(otherObs: Observable<U, V>, options?: { flushOnEnd: boolean }): Observable<T[], S>;\n    bufferWhileBy<U>(otherObs: Observable<boolean, U>, options?: { flushOnEnd?: boolean, flushOnChange?: boolean }): Observable<T[], S>;\n    awaiting<U, V>(otherObs: Observable<U, V>): Observable<boolean, S>;\n}\n\nexport class Stream<T, S> extends Observable<T, S> {\n\n}\n\nexport class Property<T, S> extends Observable<T, S> {\n\n}\n\nexport class Pool<T, S> extends Observable<T, S> {\n    plug(obs: Observable<T, S>): this;\n    unplug(obs: Observable<T, S>): this;\n}\n\nexport type Event<V,E> =\n    { type: 'value', value: V } |\n    { type: 'error', value: E } |\n    { type: 'end', value: void };\n\nexport interface Emitter<V, E> {\n    value(value: V): boolean;\n    event(event: Event<V, E>): boolean;\n    error(e: E): boolean;\n    end(): void;\n\n    // Deprecated methods\n    emit(value: V): boolean;\n    emitEvent(event: Event<V, E>): boolean;\n}\n\n// Create a stream\nexport function never(): Stream<never, never>;\nexport function later<T>(wait: number, value: T): Stream<T, never>;\nexport function interval<T>(interval: number, value: T): Stream<T, never>;\nexport function sequentially<T>(interval: number, values: T[]): Stream<T, never>;\nexport function fromPoll<T>(interval: number, fn: () => T): Stream<T, never>;\nexport function withInterval<T, S>(interval: number, handler: (emitter: Emitter<T, S>) => void): Stream<T, S>;\nexport function fromCallback<T>(fn: (callback: (value: T) => void) => void): Stream<T, never>;\nexport function fromNodeCallback<T, S>(fn: (callback: (error: S | null, result: T) => void) => void): Stream<T, S>;\nexport function fromEvents<T, S>(target: EventTarget | NodeJS.EventEmitter | { on: Function, off: Function }, eventName: string, transform?: (value: T) => S): Stream<T, S>;\nexport function stream<T, S>(subscribe: (emitter: Emitter<T, S>) => Function | void): Stream<T, S>;\nexport function fromESObservable<T, S>(observable: any): Stream<T, S>\n\n// Create a property\nexport function constant<T>(value: T): Property<T, never>;\nexport function constantError<T>(error: T): Property<never, T>;\nexport function fromPromise<T, S>(promise: Promise<T>): Property<T, S>;\n// Combine observables\nexport function combine<T, S, U>(obss: Observable<T, S>[], passiveObss: Observable<T, S>[], combinator?: (...values: T[]) => U): Stream<U, S>;\nexport function combine<T, S, U>(obss: Observable<T, S>[], combinator: (...values: T[]) => U): Stream<U, S>;\nexport function combine<T extends { [name: string]: Observable<any, any> }>(obss: T): Stream<{ [P in keyof T]: ValueOfAnObservable<T[P]> }, any>;\nexport function combine<T extends { [name: string]: Observable<any, any> }, K extends { [name: string]: Observable<any, any> }>(obss: T, passiveObss: K): Stream<{ [P in keyof T]: ValueOfAnObservable<T[P]> } & { [P in keyof K]: ValueOfAnObservable<K[P]> }, any>;\nexport function combine<T extends [Observable<any, any>], P extends keyof T>(obss: T): Stream<[ValueOfAnObservable<T[0]>], any>;\nexport function combine<T extends [Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>]>(obss: T): Stream<[ValueOfAnObservable<T[0]>, ValueOfAnObservable<T[1]>, ValueOfAnObservable<T[2]>, ValueOfAnObservable<T[3]>, ValueOfAnObservable<T[4]>, ValueOfAnObservable<T[5]>, ValueOfAnObservable<T[6]>, ValueOfAnObservable<T[7]>], any>;\nexport function combine<T extends [Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>]>(obss: T): Stream<[ValueOfAnObservable<T[0]>, ValueOfAnObservable<T[1]>, ValueOfAnObservable<T[2]>, ValueOfAnObservable<T[3]>, ValueOfAnObservable<T[4]>, ValueOfAnObservable<T[5]>, ValueOfAnObservable<T[6]>], any>;\nexport function combine<T extends [Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>, Observable<any, any>]>(obss: T): Stream<[ValueOfAnObservable<T[0]>, ValueOfAnObservable<T[1]>, ValueOfAnObservable<T[2]>, ValueOfAnObservable<T[3]>, ValueOfAnObs"
}
