{
  "master:types/asynciterator/index.d.ts": "// Type definitions for asynciterator 1.1\n// Project: https://github.com/rubenverborgh/AsyncIterator#readme\n// Definitions by: Ruben Taelman <https://github.com/rubensworks>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.4\n\n/// <reference types=\"node\" />\n\nimport { EventEmitter } from \"events\";\n\nexport abstract class AsyncIterator<T> implements EventEmitter {\n    static STATES: ['INIT', 'OPEN', 'CLOSING', 'CLOSED', 'ENDED'];\n    static INIT: 0;\n    static OPEN: 1;\n    static CLOSING: 2;\n    static CLOSED: 3;\n    static ENDED: 4;\n\n    _state: number;\n    _readable: boolean;\n    _destination?: AsyncIterator<any>;\n\n    readable: boolean;\n    closed: boolean;\n    ended: boolean;\n\n    constructor();\n\n    read(): T;\n    each(callback: (data: T) => void, self?: any): void;\n    close(): void;\n\n    _changeState(newState: number, eventAsync?: boolean): void;\n    private _hasListeners(eventName: string | symbol): boolean;\n    // tslint:disable-next-line ban-types\n    private _addSingleListener(eventName: string | symbol, listener: Function): void;\n    _end(): void;\n\n    getProperty(propertyName: string, callback?: (value: any) => void): any;\n    setProperty(propertyName: string, value: any): void;\n    getProperties(): {[id: string]: any};\n    setProperties(properties: {[id: string]: any}): void;\n    copyProperties(source: AsyncIterator<any>, propertyNames: string[]): void;\n\n    toString(): string;\n    _toStringDetails(): string;\n\n    transform<T2>(options?: SimpleTransformIteratorOptions<T, T2>): SimpleTransformIterator<T, T2>;\n    map<T2>(mapper: (item: T) => T2, self?: object): SimpleTransformIterator<T, T2>;\n    filter(filter: (item: T) => boolean, self?: object): SimpleTransformIterator<T, T>;\n    prepend(items: T[]): SimpleTransformIterator<T, T>;\n    append<T>(items: T[]): SimpleTransformIterator<T, T>;\n    surround<T>(prepend: T[], append: T[]): SimpleTransformIterator<T, T>;\n    skip<T>(offset: number): SimpleTransformIterator<T, T>;\n    take<T>(limit: number): SimpleTransformIterator<T, T>;\n    range<T>(start: number, end: number): SimpleTransformIterator<T, T>;\n    clone(): ClonedIterator<T>;\n\n    static range(start?: number, end?: number, step?: number): IntegerIterator;\n\n    // From EventEmitter\n    addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    on(event: string | symbol, listener: (...args: any[]) => void): this;\n    once(event: string | symbol, listener: (...args: any[]) => void): this;\n    removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    off(event: string | symbol, listener: (...args: any[]) => void): this;\n    removeAllListeners(event?: string | symbol): this;\n    setMaxListeners(n: number): this;\n    getMaxListeners(): number;\n    listeners(event: string | symbol): Array<() => void>;\n    rawListeners(event: string | symbol): Array<() => void>;\n    emit(event: string | symbol, ...args: any[]): boolean;\n    listenerCount(type: string | symbol): number;\n    // Added in Node 6...\n    prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    eventNames(): Array<string | symbol>;\n\n    static wrap<S>(source?: AsyncIterator<S> | TransformIteratorOptions<S> | NodeJS.ReadableStream, options?: TransformIteratorOptions<S>): TransformIterator<S, any>;\n}\n\nexport class EmptyIterator<T> extends AsyncIterator<T> {\n    _state: 4;\n}\n\nexport class SingletonIterator<T> extends AsyncIterator<T> {\n    constructor(item?: T);\n}\n\nexport class ArrayIterator<T> extends AsyncIterator<T> {\n    constructor(items?: T[]);\n}\n\nexport interface IntegerIteratorOptions {\n    step?: number;\n    end?: number;\n    start?: number;\n}\n\nexport class IntegerIterator extends AsyncIterator<number> {\n    _step: number;\n    _last: number;\n    _next: number;\n\n    constructor(options?: IntegerIteratorOptions);\n}\n\nexport interface BufferedIteratorOptions {\n    maxBufferSize?: number;\n    autoStart?: boolean;\n}\n\nexport class BufferedIterator<T> extends AsyncIterator<T> {\n    maxBufferSize: number;\n    _pushedCount: number;\n    _buffer: T[];\n\n    _init(autoStart: boolean): void;\n    _begin(done: () => void): void;\n    _read(count: number, done: () => void): void;\n    _push(item: T): void;\n    _fillBuffer(): void;\n    _completeClose(): void;\n    _flush(done: () => void): void;\n\n    constructor(options?: BufferedIteratorOptions);\n}\n\nexport interface TransformIteratorOptions<S> extends BufferedIteratorOptions {\n    optional?: boolean;\n    source?: AsyncIterator<S>;\n}\n\nexport class TransformIterator<S, T> extends BufferedIterator<T> {\n    _optional: boolean;\n    source: AsyncIterator<S>;\n\n    _validateSource(source: AsyncIterator<S>, allowDestination?: boolean): void;\n    _transform(item: S, done: (result?: T) => void): void;\n    _closeWhenDone(): void;\n\n    constructor(source?: AsyncIterator<S> | TransformIteratorOptions<S>, options?: TransformIteratorOptions<S>);\n}\n\nexport interface SimpleTransformIteratorOptions<S, T> extends TransformIteratorOptions<S> {\n    offset?: number;\n    limit?: number;\n    prepend?: T[];\n    append?: T[];\n\n    filter?(item: S): boolean;\n    map?(item: S): T;\n    transform?(item: S, callback: (result?: T) => void): void;\n}\n\nexport class SimpleTransformIterator<S, T> extends TransformIterator<S, T> {\n    _offset: number;\n    _limit: number;\n    _prepender?: ArrayIterator<T>;\n    _appender?: ArrayIterator<T>;\n\n    _filter?(item: S): boolean;\n    _map?(item: S): T;\n    _transform(item: S, done: (result?: T) => void): void;\n\n    _insert(inserter: AsyncIterator<S>, done: () => void): void;\n\n    constructor(source?: AsyncIterator<S> | SimpleTransformIteratorOptions<S, T>,\n                options?: SimpleTransformIteratorOptions<S, T>);\n}\n\nexport class MultiTransformIterator<S, T> extends TransformIterator<S, T> {\n    _transformerQueue: S[];\n\n    _createTransformer(element: S): AsyncIterator<T>;\n\n    constructor(source?: AsyncIterator<S> | TransformIteratorOptions<S>, options?: TransformIteratorOptions<S>);\n}\n\nexport class ClonedIterator<T> extends TransformIterator<T, T> {\n    _readPosition: number;\n\n    constructor(source?: AsyncIterator<T>);\n}\n"
}
