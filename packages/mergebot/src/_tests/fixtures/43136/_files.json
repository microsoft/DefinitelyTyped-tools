{
  "master:types/estree/index.d.ts": "// Type definitions for ESTree AST specification\n// Project: https://github.com/estree/estree\n// Definitions by: RReverser <https://github.com/RReverser>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n// This definition file follows a somewhat unusual format. ESTree allows\n// runtime type checks based on the `type` parameter. In order to explain this\n// to typescript we want to use discriminated union types:\n// https://github.com/Microsoft/TypeScript/pull/9163\n//\n// For ESTree this is a bit tricky because the high level interfaces like\n// Node or Function are pulling double duty. We want to pass common fields down\n// to the interfaces that extend them (like Identifier or\n// ArrowFunctionExpression), but you can't extend a type union or enforce\n// common fields on them. So we've split the high level interfaces into two\n// types, a base type which passes down inhereted fields, and a type union of\n// all types which extend the base type. Only the type union is exported, and\n// the union is how other types refer to the collection of inheriting types.\n//\n// This makes the definitions file here somewhat more difficult to maintain,\n// but it has the notable advantage of making ESTree much easier to use as\n// an end user.\n\ninterface BaseNodeWithoutComments {\n  // Every leaf interface that extends BaseNode must specify a type property.\n  // The type property should be a string literal. For example, Identifier\n  // has: `type: \"Identifier\"`\n  type: string;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n}\n\ninterface BaseNode extends BaseNodeWithoutComments {\n  leadingComments?: Array<Comment>;\n  trailingComments?: Array<Comment>;\n}\n\nexport type Node =\n    Identifier | Literal | Program | Function | SwitchCase | CatchClause |\n    VariableDeclarator | Statement | Expression | Property |\n    AssignmentProperty | Super | TemplateElement | SpreadElement | Pattern |\n    ClassBody | Class | MethodDefinition | ModuleDeclaration | ModuleSpecifier;\n\nexport interface Comment extends BaseNodeWithoutComments {\n  type: \"Line\" | \"Block\";\n  value: string;\n}\n\ninterface SourceLocation {\n  source?: string | null;\n  start: Position;\n  end: Position;\n}\n\nexport interface Position {\n  /** >= 1 */\n  line: number;\n  /** >= 0 */\n  column: number;\n}\n\nexport interface Program extends BaseNode {\n  type: \"Program\";\n  sourceType: \"script\" | \"module\";\n  body: Array<Directive | Statement | ModuleDeclaration>;\n  comments?: Array<Comment>;\n}\n\nexport interface Directive extends BaseNode {\n  type: \"ExpressionStatement\";\n  expression: Literal;\n  directive: string;\n}\n\ninterface BaseFunction extends BaseNode {\n  params: Array<Pattern>;\n  generator?: boolean;\n  async?: boolean;\n  // The body is either BlockStatement or Expression because arrow functions\n  // can have a body that's either. FunctionDeclarations and\n  // FunctionExpressions have only BlockStatement bodies.\n  body: BlockStatement | Expression;\n}\n\nexport type Function =\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression;\n\nexport type Statement =\n    ExpressionStatement | BlockStatement | EmptyStatement |\n    DebuggerStatement | WithStatement | ReturnStatement | LabeledStatement |\n    BreakStatement | ContinueStatement | IfStatement | SwitchStatement |\n    ThrowStatement | TryStatement | WhileStatement | DoWhileStatement |\n    ForStatement | ForInStatement | ForOfStatement | Declaration;\n\ninterface BaseStatement extends BaseNode { }\n\nexport interface EmptyStatement extends BaseStatement {\n  type: \"EmptyStatement\";\n}\n\nexport interface BlockStatement extends BaseStatement {\n  type: \"BlockStatement\";\n  body: Array<Statement>;\n  innerComments?: Array<Comment>;\n}\n\nexport interface ExpressionStatement extends BaseStatement {\n  type: \"ExpressionStatement\";\n  expression: Expression;\n}\n\nexport interface IfStatement extends BaseStatement {\n  type: \"IfStatement\";\n  test: Expression;\n  consequent: Statement;\n  alternate?: Statement | null;\n}\n\nexport interface LabeledStatement extends BaseStatement {\n  type: \"LabeledStatement\";\n  label: Identifier;\n  body: Statement;\n}\n\nexport interface BreakStatement extends BaseStatement {\n  type: \"BreakStatement\";\n  label?: Identifier | null;\n}\n\nexport interface ContinueStatement extends BaseStatement {\n  type: \"ContinueStatement\";\n  label?: Identifier | null;\n}\n\nexport interface WithStatement extends BaseStatement {\n  type: \"WithStatement\";\n  object: Expression;\n  body: Statement;\n}\n\nexport interface SwitchStatement extends BaseStatement {\n  type: \"SwitchStatement\";\n  discriminant: Expression;\n  cases: Array<SwitchCase>;\n}\n\nexport interface ReturnStatement extends BaseStatement {\n  type: \"ReturnStatement\";\n  argument?: Expression | null;\n}\n\nexport interface ThrowStatement extends BaseStatement {\n  type: \"ThrowStatement\";\n  argument: Expression;\n}\n\nexport interface TryStatement extends BaseStatement {\n  type: \"TryStatement\";\n  block: BlockStatement;\n  handler?: CatchClause | null;\n  finalizer?: BlockStatement | null;\n}\n\nexport interface WhileStatement extends BaseStatement {\n  type: \"WhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n\nexport interface DoWhileStatement extends BaseStatement {\n  type: \"DoWhileStatement\";\n  body: Statement;\n  test: Expression;\n}\n\nexport interface ForStatement extends BaseStatement {\n  type: \"ForStatement\";\n  init?: VariableDeclaration | Expression | null;\n  test?: Expression | null;\n  update?: Expression | null;\n  body: Statement;\n}\n\ninterface BaseForXStatement extends BaseStatement {\n  left: VariableDeclaration | Pattern;\n  right: Expression;\n  body: Statement;\n}\n\nexport interface ForInStatement extends BaseForXStatement {\n  type: \"ForInStatement\";\n}\n\nexport interface DebuggerStatement extends BaseStatement {\n  type: \"DebuggerStatement\";\n}\n\nexport type Declaration =\n      FunctionDeclaration | VariableDeclaration | ClassDeclaration;\n\ninterface BaseDeclaration extends BaseStatement { }\n\nexport interface FunctionDeclaration extends BaseFunction, BaseDeclaration {\n  type: \"FunctionDeclaration\";\n  /** It is null when a function declaration is a part of the `export default function` statement */\n  id: Identifier | null;\n  body: BlockStatement;\n}\n\nexport interface VariableDeclaration extends BaseDeclaration {\n  type: \"VariableDeclaration\";\n  declarations: Array<VariableDeclarator>;\n  kind: \"var\" | \"let\" | \"const\";\n}\n\nexport interface VariableDeclarator extends BaseNode {\n  type: \"VariableDeclarator\";\n  id: Pattern;\n  init?: Expression | null;\n}\n\ntype Expression =\n    ThisExpression | ArrayExpression | ObjectExpression | FunctionExpression |\n    ArrowFunctionExpression | YieldExpression | Literal | UnaryExpression |\n    UpdateExpression | BinaryExpression | AssignmentExpression |\n    LogicalExpression | MemberExpression | ConditionalExpression |\n    CallExpression | NewExpression | SequenceExpression | TemplateLiteral |\n    TaggedTemplateExpression | ClassExpression | MetaProperty | Identifier |\n    AwaitExpression | ImportExpression | ChainExpression;\n\nexport interface BaseExpression extends BaseNode { }\n\ntype ChainElement = SimpleCallExpression | MemberExpression;\n\nexport interface ChainExpression extends BaseExpression {\n  type: \"ChainExpression\";\n  expression: ChainElement;\n}\n\nexport interface ThisExpression extends BaseExpression {\n  type: \"ThisExpression\";\n}\n\nexport interface ArrayExpression extends BaseExpression {\n  type: \"ArrayExpression\";\n  elements: Array<Expression | SpreadElement>;\n}\n\nexport interface ObjectExpression extends BaseExpression {\n  type: \"ObjectExpression\";\n  properties: Array<Property | SpreadElement>;\n}\n\nexport interface Property extends BaseNode {\n  type: \"Property\";\n  key: Expression;\n  value: Expression | Pattern; // Could be an AssignmentProperty\n  kind: \"init\" | \"get\" | \"set\";\n  method: boolean;\n  shorthand: boolean;\n  computed: boolean;\n}\n\nexport interface FunctionExpression extends BaseFunction, BaseExpression {\n  id?: Identifier | null;\n  type: \"FunctionExpression\";\n  body: BlockStatement;\n}\n\nexport interface SequenceExpression extends BaseExpression {\n  type: \"SequenceExpression\";\n  expressions: Array<Expression>;\n}\n\nexport interface UnaryExpression extends BaseExpression {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: true;\n  argument: Expression;\n}\n\nexport interface BinaryExpression extends BaseExpression {\n  type: \"BinaryExpression\";\n  operator: BinaryOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport interface AssignmentExpression extends BaseExpression {\n  type: \"AssignmentExpression\";\n  operator: AssignmentOperator;\n  left: Pattern | MemberExpression;\n  right: Expression;\n}\n\nexport interface UpdateExpression extends BaseExpression {\n  type: \"UpdateExpression\";\n  operator: UpdateOperator;\n  argument: Expression;\n  prefix: boolean;\n}\n\nexport interface LogicalExpression extends BaseExpression {\n  type: \"LogicalExpression\";\n  operator: LogicalOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport interface ConditionalExpression extends BaseExpression {\n  type: \"ConditionalExpression\";\n  test: Expression;\n  alternate: Expression;\n  consequent: Expression;\n}\n\ninterface BaseCallExpression extends BaseExpression {\n  callee: Expression | Super;\n  arguments: Array<Expression | SpreadElement>;\n}\nexport type CallExpression = SimpleCallExpression | NewExpression;\n\nexport interface SimpleCallExpression extends BaseCallExpression {\n  type: \"CallExpression\";\n  optional: boolean;\n}\n\nexport interface NewExpression extends BaseCallExpression {\n  type: \"NewExpression\";\n}\n\nexport interface MemberExpression extends BaseExpression, BasePattern {\n  type: \"MemberExpression\";\n  object: Expression | Super;\n  property: Expression;\n  computed: boolean;\n  optional: boolean;\n}\n\nexport type Pattern =\n    Identifier | ObjectPattern | ArrayPattern | RestElement |\n    AssignmentPattern | MemberExpression;\n\ninterface BasePattern extends BaseNode { }\n\nexport interface SwitchCase extends BaseNode {\n  type: \"SwitchCase\";\n  test?: Expression | null;\n  consequent: Array<Statement>;\n}\n\nexport interface CatchClause extends BaseNode {\n  type: \"CatchClause\";\n  param: Pattern | null;\n  body: BlockStatement;\n}\n\nexport interface Identifier extends BaseNode, BaseExpression, BasePattern {\n  type: \"Ide",
  "e6863537248bbfee8f0ef8c636bb00c25cf40b96:types/estree/index.d.ts": "// Type definitions for ESTree AST specification\n// Project: https://github.com/estree/estree\n// Definitions by: RReverser <https://github.com/RReverser>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n// This definition file follows a somewhat unusual format. ESTree allows\n// runtime type checks based on the `type` parameter. In order to explain this\n// to typescript we want to use discriminated union types:\n// https://github.com/Microsoft/TypeScript/pull/9163\n//\n// For ESTree this is a bit tricky because the high level interfaces like\n// Node or Function are pulling double duty. We want to pass common fields down\n// to the interfaces that extend them (like Identifier or\n// ArrowFunctionExpression), but you can't extend a type union or enforce\n// common fields on them. So we've split the high level interfaces into two\n// types, a base type which passes down inhereted fields, and a type union of\n// all types which extend the base type. Only the type union is exported, and\n// the union is how other types refer to the collection of inheriting types.\n//\n// This makes the definitions file here somewhat more difficult to maintain,\n// but it has the notable advantage of making ESTree much easier to use as\n// an end user.\n\ninterface BaseNodeWithoutComments {\n  // Every leaf interface that extends BaseNode must specify a type property.\n  // The type property should be a string literal. For example, Identifier\n  // has: `type: \"Identifier\"`\n  type: string;\n  loc?: SourceLocation | null;\n  range?: [number, number];\n}\n\ninterface BaseNode extends BaseNodeWithoutComments {\n  leadingComments?: Array<Comment>;\n  trailingComments?: Array<Comment>;\n}\n\nexport type Node =\n    Identifier | Literal | Program | Function | SwitchCase | CatchClause |\n    VariableDeclarator | Statement | Expression | Property |\n    AssignmentProperty | Super | TemplateElement | SpreadElement | Pattern |\n    ClassBody | Class | MethodDefinition | ModuleDeclaration | ModuleSpecifier;\n\nexport interface Comment extends BaseNodeWithoutComments {\n  type: \"Line\" | \"Block\";\n  value: string;\n}\n\ninterface SourceLocation {\n  source?: string | null;\n  start: Position;\n  end: Position;\n}\n\nexport interface Position {\n  /** >= 1 */\n  line: number;\n  /** >= 0 */\n  column: number;\n}\n\nexport interface Program extends BaseNode {\n  type: \"Program\";\n  sourceType: \"script\" | \"module\";\n  body: Array<Directive | Statement | ModuleDeclaration>;\n  comments?: Array<Comment>;\n}\n\nexport interface Directive extends BaseNode {\n  type: \"ExpressionStatement\";\n  expression: Literal;\n  directive: string;\n}\n\ninterface BaseFunction extends BaseNode {\n  params: Array<Pattern>;\n  generator?: boolean;\n  async?: boolean;\n  // The body is either BlockStatement or Expression because arrow functions\n  // can have a body that's either. FunctionDeclarations and\n  // FunctionExpressions have only BlockStatement bodies.\n  body: BlockStatement | Expression;\n}\n\nexport type Function =\n    FunctionDeclaration | FunctionExpression | ArrowFunctionExpression;\n\nexport type Statement =\n    ExpressionStatement | BlockStatement | EmptyStatement |\n    DebuggerStatement | WithStatement | ReturnStatement | LabeledStatement |\n    BreakStatement | ContinueStatement | IfStatement | SwitchStatement |\n    ThrowStatement | TryStatement | WhileStatement | DoWhileStatement |\n    ForStatement | ForInStatement | ForOfStatement | Declaration;\n\ninterface BaseStatement extends BaseNode { }\n\nexport interface EmptyStatement extends BaseStatement {\n  type: \"EmptyStatement\";\n}\n\nexport interface BlockStatement extends BaseStatement {\n  type: \"BlockStatement\";\n  body: Array<Statement>;\n  innerComments?: Array<Comment>;\n}\n\nexport interface ExpressionStatement extends BaseStatement {\n  type: \"ExpressionStatement\";\n  expression: Expression;\n}\n\nexport interface IfStatement extends BaseStatement {\n  type: \"IfStatement\";\n  test: Expression;\n  consequent: Statement;\n  alternate?: Statement | null;\n}\n\nexport interface LabeledStatement extends BaseStatement {\n  type: \"LabeledStatement\";\n  label: Identifier;\n  body: Statement;\n}\n\nexport interface BreakStatement extends BaseStatement {\n  type: \"BreakStatement\";\n  label?: Identifier | null;\n}\n\nexport interface ContinueStatement extends BaseStatement {\n  type: \"ContinueStatement\";\n  label?: Identifier | null;\n}\n\nexport interface WithStatement extends BaseStatement {\n  type: \"WithStatement\";\n  object: Expression;\n  body: Statement;\n}\n\nexport interface SwitchStatement extends BaseStatement {\n  type: \"SwitchStatement\";\n  discriminant: Expression;\n  cases: Array<SwitchCase>;\n}\n\nexport interface ReturnStatement extends BaseStatement {\n  type: \"ReturnStatement\";\n  argument?: Expression | null;\n}\n\nexport interface ThrowStatement extends BaseStatement {\n  type: \"ThrowStatement\";\n  argument: Expression;\n}\n\nexport interface TryStatement extends BaseStatement {\n  type: \"TryStatement\";\n  block: BlockStatement;\n  handler?: CatchClause | null;\n  finalizer?: BlockStatement | null;\n}\n\nexport interface WhileStatement extends BaseStatement {\n  type: \"WhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n\nexport interface DoWhileStatement extends BaseStatement {\n  type: \"DoWhileStatement\";\n  body: Statement;\n  test: Expression;\n}\n\nexport interface ForStatement extends BaseStatement {\n  type: \"ForStatement\";\n  init?: VariableDeclaration | Expression | null;\n  test?: Expression | null;\n  update?: Expression | null;\n  body: Statement;\n}\n\ninterface BaseForXStatement extends BaseStatement {\n  left: VariableDeclaration | Pattern;\n  right: Expression;\n  body: Statement;\n}\n\nexport interface ForInStatement extends BaseForXStatement {\n  type: \"ForInStatement\";\n}\n\nexport interface DebuggerStatement extends BaseStatement {\n  type: \"DebuggerStatement\";\n}\n\nexport type Declaration =\n      FunctionDeclaration | VariableDeclaration | ClassDeclaration;\n\ninterface BaseDeclaration extends BaseStatement { }\n\nexport interface FunctionDeclaration extends BaseFunction, BaseDeclaration {\n  type: \"FunctionDeclaration\";\n  /** It is null when a function declaration is a part of the `export default function` statement */\n  id: Identifier | null;\n  body: BlockStatement;\n}\n\nexport interface VariableDeclaration extends BaseDeclaration {\n  type: \"VariableDeclaration\";\n  declarations: Array<VariableDeclarator>;\n  kind: \"var\" | \"let\" | \"const\";\n}\n\nexport interface VariableDeclarator extends BaseNode {\n  type: \"VariableDeclarator\";\n  id: Pattern;\n  init?: Expression | null;\n}\n\ntype Expression =\n    ThisExpression | ArrayExpression | ObjectExpression | FunctionExpression |\n    ArrowFunctionExpression | YieldExpression | Literal | UnaryExpression |\n    UpdateExpression | BinaryExpression | AssignmentExpression |\n    LogicalExpression | MemberExpression | ConditionalExpression |\n    CallExpression | NewExpression | SequenceExpression | TemplateLiteral |\n    TaggedTemplateExpression | ClassExpression | MetaProperty | Identifier |\n    AwaitExpression | ImportExpression | ChainExpression;\n\nexport interface BaseExpression extends BaseNode { }\n\ntype ChainElement = SimpleCallExpression | MemberExpression;\n\nexport interface ChainExpression extends BaseExpression {\n  type: \"ChainExpression\";\n  expression: ChainElement;\n}\n\nexport interface ThisExpression extends BaseExpression {\n  type: \"ThisExpression\";\n}\n\nexport interface ArrayExpression extends BaseExpression {\n  type: \"ArrayExpression\";\n  elements: Array<Expression | SpreadElement>;\n}\n\nexport interface ObjectExpression extends BaseExpression {\n  type: \"ObjectExpression\";\n  properties: Array<Property | SpreadElement>;\n}\n\nexport interface Property extends BaseNode {\n  type: \"Property\";\n  key: Expression;\n  value: Expression | Pattern; // Could be an AssignmentProperty\n  kind: \"init\" | \"get\" | \"set\";\n  method: boolean;\n  shorthand: boolean;\n  computed: boolean;\n}\n\nexport interface FunctionExpression extends BaseFunction, BaseExpression {\n  id?: Identifier | null;\n  type: \"FunctionExpression\";\n  body: BlockStatement;\n}\n\nexport interface SequenceExpression extends BaseExpression {\n  type: \"SequenceExpression\";\n  expressions: Array<Expression>;\n}\n\nexport interface UnaryExpression extends BaseExpression {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: true;\n  argument: Expression;\n}\n\nexport interface BinaryExpression extends BaseExpression {\n  type: \"BinaryExpression\";\n  operator: BinaryOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport interface AssignmentExpression extends BaseExpression {\n  type: \"AssignmentExpression\";\n  operator: AssignmentOperator;\n  left: Pattern | MemberExpression;\n  right: Expression;\n}\n\nexport interface UpdateExpression extends BaseExpression {\n  type: \"UpdateExpression\";\n  operator: UpdateOperator;\n  argument: Expression;\n  prefix: boolean;\n}\n\nexport interface LogicalExpression extends BaseExpression {\n  type: \"LogicalExpression\";\n  operator: LogicalOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport interface ConditionalExpression extends BaseExpression {\n  type: \"ConditionalExpression\";\n  test: Expression;\n  alternate: Expression;\n  consequent: Expression;\n}\n\ninterface BaseCallExpression extends BaseExpression {\n  callee: Expression | Super;\n  arguments: Array<Expression | SpreadElement>;\n}\nexport type CallExpression = SimpleCallExpression | NewExpression;\n\nexport interface SimpleCallExpression extends BaseCallExpression {\n  type: \"CallExpression\";\n  optional: boolean;\n}\n\nexport interface NewExpression extends BaseCallExpression {\n  type: \"NewExpression\";\n}\n\nexport interface MemberExpression extends BaseExpression, BasePattern {\n  type: \"MemberExpression\";\n  object: Expression | Super;\n  property: Expression;\n  computed: boolean;\n  optional: boolean;\n}\n\nexport type Pattern =\n    Identifier | ObjectPattern | ArrayPattern | RestElement |\n    AssignmentPattern | MemberExpression;\n\ninterface BasePattern extends BaseNode { }\n\nexport interface SwitchCase extends BaseNode {\n  type: \"SwitchCase\";\n  test?: Expression | null;\n  consequent: Array<Statement>;\n}\n\nexport interface CatchClause extends BaseNode {\n  type: \"CatchClause\";\n  param: Pattern | null;\n  body: BlockStatement;\n}\n\nexport interface Identifier extends BaseNode, BaseExpression, BasePattern {\n  type: \"Ide"
}
