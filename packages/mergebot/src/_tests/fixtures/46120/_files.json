{
  "master:types/underscore/index.d.ts": "// Type definitions for Underscore 1.10\n// Project: http://underscorejs.org/\n// Definitions by: Boris Yankov <https://github.com/borisyankov>,\n//                 Josh Baldwin <https://github.com/jbaldwin>,\n//                 Christopher Currens <https://github.com/ccurrens>,\n//                 Ard Timmerman <https://github.com/confususs>,\n//                 Julian Gonggrijp <https://github.com/jgonggrijp>,\n//                 Florian Keller <https://github.com/ffflorian>\n//                 Regev Brody <https://github.com/regevbr>\n//                 Piotr Błażejewicz <https://github.com/peterblazejewicz>\n//                 Michael Ness <https://github.com/reubenrybnik>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.8\n\ndeclare var _: _.UnderscoreStatic;\nexport = _;\nexport as namespace _;\n\n// The DOM is not required to be present, but these definitions reference type Element for the\n// isElement check. If the DOM is present, this declaration will merge.\ndeclare global {\n    interface Element { }\n}\n\ndeclare module _ {\n    /**\n    * underscore.js _.throttle options.\n    **/\n    interface ThrottleSettings {\n\n        /**\n        * If you'd like to disable the leading-edge call, pass this as false.\n        **/\n        leading?: boolean;\n\n        /**\n        * If you'd like to disable the execution on the trailing-edge, pass false.\n        **/\n        trailing?: boolean;\n    }\n\n    /**\n    * underscore.js template settings, set templateSettings or pass as an argument\n    * to 'template()' to override defaults.\n    **/\n    interface TemplateSettings {\n        /**\n        * Default value is '/<%([\\s\\S]+?)%>/g'.\n        **/\n        evaluate?: RegExp;\n\n        /**\n        * Default value is '/<%=([\\s\\S]+?)%>/g'.\n        **/\n        interpolate?: RegExp;\n\n        /**\n        * Default value is '/<%-([\\s\\S]+?)%>/g'.\n        **/\n        escape?: RegExp;\n\n        /**\n        * By default, 'template()' places the values from your data in the local scope via the 'with' statement.\n        * However, you can specify a single variable name with this setting.\n        **/\n        variable?: string;\n    }\n\n    interface CompiledTemplate {\n        (data?: any): string;\n        source: string;\n    }\n\n    // Common interface between Arrays and jQuery objects\n    interface List<T> {\n        [index: number]: T;\n        length: number;\n    }\n\n    interface Dictionary<T> {\n        [index: string]: T;\n    }\n\n    type Collection<T> = List<T> | Dictionary<T>;\n\n    type EnumerableKey = string | number;\n\n    type CollectionKey<V> =\n        V extends never ? any\n        : V extends List<any> ? number\n        : V extends Dictionary<any> ? string\n        : V extends undefined ? undefined\n        : never;\n\n    interface Predicate<T> {\n        (value: T): boolean;\n    }\n\n    interface CollectionIterator<T extends TypeOfCollection<V, any>, TResult, V = Collection<T>> {\n        (element: T, key: CollectionKey<V>, collection: V): TResult;\n    }\n\n    interface ListIterator<T extends TypeOfList<V>, TResult, V = List<T>> extends CollectionIterator<T, TResult, V> { }\n\n    interface ObjectIterator<T extends TypeOfDictionary<V, any>, TResult, V = Dictionary<T>> extends CollectionIterator<T, TResult, V> { }\n\n    type Iteratee<V, R, T extends TypeOfCollection<V, any> = TypeOfCollection<V>> =\n        CollectionIterator<T, R, V> |\n        EnumerableKey |\n        EnumerableKey[] |\n        Partial<T> |\n        null |\n        undefined;\n\n    type IterateeResult<I, T> =\n        I extends (...args: any[]) => infer R ? R\n        : I extends keyof T ? T[I]\n        : I extends EnumerableKey | EnumerableKey[] ? any\n        : I extends object ? boolean\n        : I extends null | undefined ? T\n        : never;\n\n    type PropertyTypeOrAny<T, K> = K extends keyof T ? T[K] : any;\n\n    interface MemoCollectionIterator<T extends TypeOfCollection<V>, TResult, V = Collection<T>> {\n        (prev: TResult, curr: T, key: CollectionKey<V>, collection: V): TResult;\n    }\n\n    interface MemoIterator<T extends TypeOfList<V>, TResult, V = List<T>> extends MemoCollectionIterator<T, TResult, V> { }\n\n    interface MemoObjectIterator<T extends TypeOfDictionary<V>, TResult, V = Dictionary<T>> extends MemoCollectionIterator<T, TResult, V> { }\n\n    type TypeOfList<V> =\n        V extends never ? any\n        : V extends List<infer T> ? T\n        : never;\n\n    type TypeOfDictionary<V, TDefault = never> =\n        V extends never ? any\n        : V extends Dictionary<infer T> ? T\n        : TDefault;\n\n    type TypeOfCollection<V, TObjectDefault = never> = TypeOfList<V> | TypeOfDictionary<V, TObjectDefault>;\n\n    type ListItemOrSelf<T> = T extends List<infer TItem> ? TItem : T;\n\n    // unfortunately it's not possible to recursively collapse all possible list dimensions to T[] at this time,\n    // so give up after one dimension since that's likely the most common case\n    // '& object' prevents strings from being matched by list checks so types like string[] don't end up resulting in any\n    type DeepestListItemOrSelf<T> =\n        T extends List<infer TItem> & object\n        ? TItem extends List<any> & object\n        ? any\n        : TItem\n        : T;\n\n    // if T is an inferrable pair, the value type for the pair\n    // if T is a list, assume that it contains pairs of some type, so any\n    // if T isn't a list, there's no way that it can provide pairs, so never\n    type PairValue<T> =\n        T extends Readonly<[EnumerableKey, infer TValue]> ? TValue\n        : T extends List<infer TValue> ? TValue\n        : never;\n\n    type AnyFalsy = undefined | null | false | '' | 0;\n\n    type Truthy<T> = Exclude<T, AnyFalsy>;\n\n    type _Pick<V, K extends string> =\n        Extract<K, keyof V> extends never ? Partial<V>\n        : Pick<V, Extract<K, keyof V>>;\n\n    // switch to Omit when the minimum TS version moves past 3.5\n    type _Omit<V, K extends string> =\n        V extends never ? any\n        : Extract<K, keyof V> extends never ? Partial<V>\n        : Pick<V, Exclude<keyof V, K>>;\n\n    type _ChainSingle<V> = _Chain<TypeOfCollection<V>, V>;\n\n    interface Cancelable {\n        cancel(): void;\n    }\n\n    interface UnderscoreStatic {\n        /**\n         * Underscore OOP Wrapper, all Underscore functions that take an object\n         * as the first parameter can be invoked through this function.\n         * @param value First argument to Underscore object functions.\n         * @returns An Underscore wrapper around the supplied value.\n         **/\n        <V>(value: V): Underscore<TypeOfCollection<V>, V>;\n\n        /***************\n         * Collections *\n         ***************/\n\n        /**\n         * Iterates over a `collection` of elements, yielding each in turn to\n         * an `iteratee`. The `iteratee` is bound to the context object, if one\n         * is passed.\n         * @param collection The collection of elements to iterate over.\n         * @param iteratee The iteratee to call for each element in\n         * `collection`.\n         * @param context 'this' object in `iteratee`, optional.\n         * @returns The original collection.\n         **/\n        each<V extends Collection<any>>(\n            collection: V,\n            iteratee: CollectionIterator<TypeOfCollection<V>, void, V>,\n            context?: any\n        ): V;\n\n        /**\n         * @see each\n         **/\n        forEach: UnderscoreStatic['each'];\n\n        /**\n         * Produces a new array of values by mapping each value in `collection`\n         * through a transformation `iteratee`.\n         * @param collection The collection to transform.\n         * @param iteratee The iteratee to use to transform each item in\n         * `collection`.\n         * @param context `this` object in `iteratee`, optional.\n         * @returns The mapped result.\n         **/\n        map<V extends Collection<any>, I extends Iteratee<V, any>>(\n            collection: V,\n            iteratee: I,\n            context?: any\n        ): IterateeResult<I, TypeOfCollection<V>>[];\n\n        /**\n         * @see map\n         **/\n        collect: UnderscoreStatic['map'];\n\n        /**\n         * Also known as inject and foldl, reduce boils down a `collection` of\n         * values into a single value. `memo` is the initial state of the\n         * reduction, and each successive step of it should be returned by\n         * `iteratee`.\n         *\n         * If no memo is passed to the initial invocation of reduce, `iteratee`\n         * is not invoked on the first element of `collection`. The first\n         * element is instead passed as the memo in the invocation of\n         * `iteratee` on the next element in `collection`.\n         * @param collection The collection to reduce.\n         * @param iteratee The function to call on each iteration to reduce the\n         * collection.\n         * @param memo The initial reduce state or undefined to use the first\n         * item in `collection` as initial state.\n         * @param context `this` object in `iteratee`, optional.\n         * @returns The reduced result.\n         **/\n        reduce<V extends Collection<any>, TResult>(\n            collection: V,\n            iteratee: MemoCollectionIterator<TypeOfCollection<V>, TResult, V>,\n            memo: TResult,\n            context?: any\n        ): TResult;\n        reduce<V extends Collection<any>, TResult = TypeOfCollection<V>>(\n            collection: V,\n            iteratee: MemoCollectionIterator<TypeOfCollection<V>,\n                TResult | TypeOfCollection<V>,\n                V>\n        ): TResult | TypeOfCollection<V> | undefined;\n\n        /**\n         * @see reduce\n         **/\n        inject: UnderscoreStatic['reduce'];\n\n        /**\n         * @see reduce\n         **/\n        foldl: UnderscoreStatic['reduce'];\n\n        /**\n         * The right-associative version of reduce.\n         *\n         * This is not as useful in JavaScript as it would be in a language\n         * with lazy evaluation.\n         * @param collection The collection to reduce.\n         * @param iteratee The function to call on each iteration to reduce the\n         * collection.\n         * @param memo The initial reduce state or undefined to use the first\n         * item in `collection` as the initial state.\n         ",
  "5ef8fe2907257beac41e27c3dc2399a087eddb67:types/underscore/index.d.ts": "// Type definitions for Underscore 1.10\n// Project: http://underscorejs.org/\n// Definitions by: Boris Yankov <https://github.com/borisyankov>,\n//                 Josh Baldwin <https://github.com/jbaldwin>,\n//                 Christopher Currens <https://github.com/ccurrens>,\n//                 Ard Timmerman <https://github.com/confususs>,\n//                 Julian Gonggrijp <https://github.com/jgonggrijp>,\n//                 Florian Keller <https://github.com/ffflorian>\n//                 Regev Brody <https://github.com/regevbr>\n//                 Piotr Błażejewicz <https://github.com/peterblazejewicz>\n//                 Michael Ness <https://github.com/reubenrybnik>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.8\n\ndeclare var _: _.UnderscoreStatic;\nexport = _;\nexport as namespace _;\n\n// The DOM is not required to be present, but these definitions reference type Element for the\n// isElement check. If the DOM is present, this declaration will merge.\ndeclare global {\n    interface Element { }\n}\n\ndeclare module _ {\n    /**\n    * underscore.js _.throttle options.\n    **/\n    interface ThrottleSettings {\n\n        /**\n        * If you'd like to disable the leading-edge call, pass this as false.\n        **/\n        leading?: boolean;\n\n        /**\n        * If you'd like to disable the execution on the trailing-edge, pass false.\n        **/\n        trailing?: boolean;\n    }\n\n    /**\n    * underscore.js template settings, set templateSettings or pass as an argument\n    * to 'template()' to override defaults.\n    **/\n    interface TemplateSettings {\n        /**\n        * Default value is '/<%([\\s\\S]+?)%>/g'.\n        **/\n        evaluate?: RegExp;\n\n        /**\n        * Default value is '/<%=([\\s\\S]+?)%>/g'.\n        **/\n        interpolate?: RegExp;\n\n        /**\n        * Default value is '/<%-([\\s\\S]+?)%>/g'.\n        **/\n        escape?: RegExp;\n\n        /**\n        * By default, 'template()' places the values from your data in the local scope via the 'with' statement.\n        * However, you can specify a single variable name with this setting.\n        **/\n        variable?: string;\n    }\n\n    interface CompiledTemplate {\n        (data?: any): string;\n        source: string;\n    }\n\n    // Common interface between Arrays and jQuery objects\n    interface List<T> {\n        [index: number]: T;\n        length: number;\n    }\n\n    interface Dictionary<T> {\n        [index: string]: T;\n    }\n\n    type Collection<T> = List<T> | Dictionary<T>;\n\n    type EnumerableKey = string | number;\n\n    type CollectionKey<V> =\n        V extends never ? any\n        : V extends List<any> ? number\n        : V extends Dictionary<any> ? string\n        : V extends undefined ? undefined\n        : never;\n\n    interface Predicate<T> {\n        (value: T): boolean;\n    }\n\n    interface CollectionIterator<T extends TypeOfCollection<V, any>, TResult, V = Collection<T>> {\n        (element: T, key: CollectionKey<V>, collection: V): TResult;\n    }\n\n    interface ListIterator<T extends TypeOfList<V>, TResult, V = List<T>> extends CollectionIterator<T, TResult, V> { }\n\n    interface ObjectIterator<T extends TypeOfDictionary<V, any>, TResult, V = Dictionary<T>> extends CollectionIterator<T, TResult, V> { }\n\n    type Iteratee<V, R, T extends TypeOfCollection<V, any> = TypeOfCollection<V>> =\n        CollectionIterator<T, R, V> |\n        EnumerableKey |\n        EnumerableKey[] |\n        Partial<T> |\n        null |\n        undefined;\n\n    type IterateeResult<I, T> =\n        I extends (...args: any[]) => infer R ? R\n        : I extends keyof T ? T[I]\n        : I extends EnumerableKey | EnumerableKey[] ? any\n        : I extends object ? boolean\n        : I extends null | undefined ? T\n        : never;\n\n    type PropertyTypeOrAny<T, K> = K extends keyof T ? T[K] : any;\n\n    interface MemoCollectionIterator<T extends TypeOfCollection<V>, TResult, V = Collection<T>> {\n        (prev: TResult, curr: T, key: CollectionKey<V>, collection: V): TResult;\n    }\n\n    interface MemoIterator<T extends TypeOfList<V>, TResult, V = List<T>> extends MemoCollectionIterator<T, TResult, V> { }\n\n    interface MemoObjectIterator<T extends TypeOfDictionary<V>, TResult, V = Dictionary<T>> extends MemoCollectionIterator<T, TResult, V> { }\n\n    type TypeOfList<V> =\n        V extends never ? any\n        : V extends List<infer T> ? T\n        : never;\n\n    type TypeOfDictionary<V, TDefault = never> =\n        V extends never ? any\n        : V extends Dictionary<infer T> ? T\n        : TDefault;\n\n    type TypeOfCollection<V, TObjectDefault = never> = TypeOfList<V> | TypeOfDictionary<V, TObjectDefault>;\n\n    type ListItemOrSelf<T> = T extends List<infer TItem> ? TItem : T;\n\n    // unfortunately it's not possible to recursively collapse all possible list dimensions to T[] at this time,\n    // so give up after one dimension since that's likely the most common case\n    // '& object' prevents strings from being matched by list checks so types like string[] don't end up resulting in any\n    type DeepestListItemOrSelf<T> =\n        T extends List<infer TItem> & object\n        ? TItem extends List<any> & object\n        ? any\n        : TItem\n        : T;\n\n    // if T is an inferrable pair, the value type for the pair\n    // if T is a list, assume that it contains pairs of some type, so any\n    // if T isn't a list, there's no way that it can provide pairs, so never\n    type PairValue<T> =\n        T extends Readonly<[EnumerableKey, infer TValue]> ? TValue\n        : T extends List<infer TValue> ? TValue\n        : never;\n\n    type AnyFalsy = undefined | null | false | '' | 0;\n\n    type Truthy<T> = Exclude<T, AnyFalsy>;\n\n    type _Pick<V, K extends string> =\n        Extract<K, keyof V> extends never ? Partial<V>\n        : Pick<V, Extract<K, keyof V>>;\n\n    // switch to Omit when the minimum TS version moves past 3.5\n    type _Omit<V, K extends string> =\n        V extends never ? any\n        : Extract<K, keyof V> extends never ? Partial<V>\n        : Pick<V, Exclude<keyof V, K>>;\n\n    type _ChainSingle<V> = _Chain<TypeOfCollection<V>, V>;\n\n    interface Cancelable {\n        cancel(): void;\n    }\n\n    interface UnderscoreStatic {\n        /**\n         * Underscore OOP Wrapper, all Underscore functions that take an object\n         * as the first parameter can be invoked through this function.\n         * @param value First argument to Underscore object functions.\n         * @returns An Underscore wrapper around the supplied value.\n         **/\n        <V>(value: V): Underscore<TypeOfCollection<V>, V>;\n\n        /***************\n         * Collections *\n         ***************/\n\n        /**\n         * Iterates over a `collection` of elements, yielding each in turn to\n         * an `iteratee`. The `iteratee` is bound to the context object, if one\n         * is passed.\n         * @param collection The collection of elements to iterate over.\n         * @param iteratee The iteratee to call for each element in\n         * `collection`.\n         * @param context 'this' object in `iteratee`, optional.\n         * @returns The original collection.\n         **/\n        each<V extends Collection<any>>(\n            collection: V,\n            iteratee: CollectionIterator<TypeOfCollection<V>, void, V>,\n            context?: any\n        ): V;\n\n        /**\n         * @see each\n         **/\n        forEach: UnderscoreStatic['each'];\n\n        /**\n         * Produces a new array of values by mapping each value in `collection`\n         * through a transformation `iteratee`.\n         * @param collection The collection to transform.\n         * @param iteratee The iteratee to use to transform each item in\n         * `collection`.\n         * @param context `this` object in `iteratee`, optional.\n         * @returns The mapped result.\n         **/\n        map<V extends Collection<any>, I extends Iteratee<V, any>>(\n            collection: V,\n            iteratee: I,\n            context?: any\n        ): IterateeResult<I, TypeOfCollection<V>>[];\n\n        /**\n         * @see map\n         **/\n        collect: UnderscoreStatic['map'];\n\n        /**\n         * Also known as inject and foldl, reduce boils down a `collection` of\n         * values into a single value. `memo` is the initial state of the\n         * reduction, and each successive step of it should be returned by\n         * `iteratee`.\n         *\n         * If no memo is passed to the initial invocation of reduce, `iteratee`\n         * is not invoked on the first element of `collection`. The first\n         * element is instead passed as the memo in the invocation of\n         * `iteratee` on the next element in `collection`.\n         * @param collection The collection to reduce.\n         * @param iteratee The function to call on each iteration to reduce the\n         * collection.\n         * @param memo The initial reduce state or undefined to use the first\n         * item in `collection` as initial state.\n         * @param context `this` object in `iteratee`, optional.\n         * @returns The reduced result.\n         **/\n        reduce<V extends Collection<any>, TResult>(\n            collection: V,\n            iteratee: MemoCollectionIterator<TypeOfCollection<V>, TResult, V>,\n            memo: TResult,\n            context?: any\n        ): TResult;\n        reduce<V extends Collection<any>, TResult = TypeOfCollection<V>>(\n            collection: V,\n            iteratee: MemoCollectionIterator<TypeOfCollection<V>,\n                TResult | TypeOfCollection<V>,\n                V>\n        ): TResult | TypeOfCollection<V> | undefined;\n\n        /**\n         * @see reduce\n         **/\n        inject: UnderscoreStatic['reduce'];\n\n        /**\n         * @see reduce\n         **/\n        foldl: UnderscoreStatic['reduce'];\n\n        /**\n         * The right-associative version of reduce.\n         *\n         * This is not as useful in JavaScript as it would be in a language\n         * with lazy evaluation.\n         * @param collection The collection to reduce.\n         * @param iteratee The function to call on each iteration to reduce the\n         * collection.\n         * @param memo The initial reduce state or undefined to use the first\n         * item in `collection` as the initial state.\n         "
}
