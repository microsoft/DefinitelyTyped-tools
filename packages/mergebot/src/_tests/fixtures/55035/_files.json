{
  "master:types/jsreport-core/index.d.ts": "// Type definitions for jsreport-core 2.0\n// Project: http://jsreport.net\n// Definitions by: taoqf <https://github.com/taoqf>\n//                 pofider <https://github.com/pofider>\n//                 Keith Kikta <https://github.com/newbish>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/// <reference types=\"node\" />\n\nimport * as fs from 'fs';\n\ndeclare namespace JsReport {\n    type Helpers = string | { [fun: string]: (...args: any[]) => any };\n\n    type Engine = \"none\";\n\n    type Recipe = \"html\";\n\n    interface TemplateBase {\n        /** template for the engine */\n        content?: string | undefined;\n        /** templating engine used to assemble document */\n        engine: Engine | string;\n        /** javascript helper functions used by templating engines */\n        helpers?: Helpers | undefined;\n        /** recipe used for printing previously assembled document */\n        recipe: Recipe | string;\n        pathToEngine?: string | undefined;\n    }\n\n    interface Template extends TemplateBase {\n        /** template for the engine */\n        content: string;\n    }\n\n    interface TemplateRegistry {\n        Template: Template;\n    }\n\n    type TemplateLike = TemplateRegistry[keyof TemplateRegistry]; // Template | NamedTemplate\n\n    interface RequestOptions {\n        preview?: boolean | undefined;\n        /** sets the request timeout in milliseconds */\n        timeout?: number | undefined;\n        /** defines the name of the report being to be generated */\n        reportName?: string | undefined;\n    }\n\n    interface Request {\n        /** @default true */\n        value?: boolean | undefined;\n        /** @default false */\n        writable?: boolean | undefined;\n        /** @default false */\n        configurable?: boolean | undefined;\n        /** @default false */\n        enumerable?: boolean | undefined;\n        /** defines the template of used for report generation */\n        template: TemplateLike;\n        /** defines options such as report name and request timeout */\n        options?: Partial<RequestOptions> | undefined;\n        context?: Context | undefined;\n        data?: any;\n    }\n\n    interface Context {\n        shared?: any;\n        originalInputDataIsEmpty?: boolean | undefined;\n        isChildRequest?: boolean | undefined;\n        logs: any;\n        timeoutLimit: number;\n    }\n\n    interface Response {\n        content: Buffer;\n        stream: NodeJS.ReadableStream;\n        headers: {\n            [header: string]: string | number | boolean;\n        };\n    }\n\n    interface ListenerCollection {\n        add(\n            type: string,\n            callback: (req: Request, res: Response, err?: any) => Promise<any> | void\n        ): void;\n    }\n\n    interface Collection {\n        find(query: { [field: string]: any }): Promise<object[]>;\n        update(query: { [field: string]: any }, update: object, options?: object): Promise<any>;\n        remove(query: { [field: string]: any }): Promise<any>;\n        insert(obj: object): Promise<object>;\n    }\n\n    interface DocumentStore {\n        collection(name: string): Collection;\n    }\n\n    type Extension = (reporter: Reporter, definition: object) => void;\n\n    interface ExtensionDefinition {\n        options: any;\n        main: any;\n        directory: string;\n    }\n\n    interface ReporterInstance {\n        defaults?: Defaults | undefined;\n        options?: Configuration | undefined;\n        afterRenderListeners: ListenerCollection;\n        afterTemplatingEnginesExecutedListeners: ListenerCollection;\n        beforeRenderListeners: ListenerCollection;\n        closeListeners: ListenerCollection;\n        documentStore: DocumentStore;\n        blobStorage: BlobStorage;\n        initializeListeners: ListenerCollection;\n        renderErrorListeners: ListenerCollection;\n        // it would be nice to add winston.LoggerInstance here\n        // however adding import winston = require('winston') breaks exported enums\n        logger?: any;\n        validateRenderListeners: ListenerCollection;\n        version?: string | undefined;\n        settings: Settings;\n        optionsValidator: SchemaValidator;\n        entityTypeValidator: SchemaValidator;\n    }\n\n    interface Reporter extends ReporterInstance {\n        use(extension: Extension | ExtensionDefinition): Reporter;\n        init(): Promise<Reporter>;\n        render(request: Request, parent?: Request): Promise<Response>;\n        discover(): Reporter;\n        createListenerCollection(): ListenerCollection;\n        close(): Promise<void>;\n        extensionsLoad(opts: any): Promise<Reporter>;\n        checkValidEntityName(c: string, doc: any, req: Request): Promise<void>;\n        createError(message: string, options?: any): any;\n        getAvailableRenderTimeout(req: Request, defaultValue: number): number;\n        executeScript(inputs: any, options: any, req: Request): Promise<any>;\n        afterConfigLoaded(cb: () => void): Reporter;\n        addRequestContextMetaConfig(property: any, options: any): void;\n        getRequestContextMetaConfig(property: any): any;\n        addPathToWatchForAutoCleanup(customPath: string): void;\n        getPathsToWatchForAutoCleanup(): string[];\n        ensureTempDirectoryExists(): Promise<TempDirectoryResult>;\n        readTempFile(filename: string, opts: any): Promise<ReadTempFileResult>;\n        writeTempFile(filenameFn: () => string, content: any, opts: any): Promise<WriteFileResult>;\n        readTempFileStream(filename: string, opts: any): Promise<ReadTempFileStreamResult>;\n        writeTempFileStream(filenameFn: () => string, opts: any): Promise<WriteFileStreamResult>;\n        silentLogs(logger: any): void;\n    }\n\n    interface Defaults {\n        loadConfig?: boolean | undefined;\n        rootDirectory?: string | undefined;\n    }\n\n    type ReporterOptionsStoreProvider = 'memory';\n    type ReporterOptionsBlobStorageProvider = 'memory' | 'fs';\n    type EngineStrategy = 'dedicated-process' | 'http-server' | 'in-process';\n\n    interface Configuration {\n        mode?: any;\n        /** specifies where is the application root and where jsreport searches for extensions */\n        rootDirectory?: string | undefined;\n        /** specifies directory of the script that was used to start node.js, this value is mostly metadata that is useful for your own code inside jsreport scripts */\n        appDirectory?: string | undefined;\n        /**\n         * specifies where jsreport stores temporary files used by the conversion pipelineDef\n         * @default getDefaultTempDirectory()\n         */\n        tempDirectory?: string | undefined;\n        /**\n         * specifies if jsreport should load configuration values from external sources (cli args, env vars, configuration files) or not\n         * @default getDefaultLoadConfig()\n         */\n        loadConfig?: boolean | undefined;\n        /** specifies if after some interval jsreport should automatically clean up temporary files generated while rendering reports */\n        autoTempCleanup?: boolean | undefined;\n        /** specifies if jsreport should discover/search installed extensions in project and use them automatically */\n        discover?: boolean | undefined;\n        /**\n         * wheter if jsreport should read list of extensions from a previous generated cache or if it should crawl and try to search extensions again, set it to false when you want to always\n         * force crawling node_modules when searching for extensions while starting jsreport\n         * @default true\n         */\n        useExtensionsLocationCache?: boolean | undefined;\n        logger?: {\n            silent?: boolean | undefined;\n        } | undefined;\n        /** global single timeout that controls how much a report generation should wait before it times out */\n        reportTimeout?: number | undefined;\n        /**\n         * option that enables passing a custom report timeout per request using req.options.timeout. this enables that the caller of the report generation control the report timeout so enable it\n         * only when you trust the caller\n         * @default false\n         */\n        enableRequestReportTimeout?: boolean | undefined;\n        /** @default false */\n        allowLocalFilesAccess?: boolean | undefined;\n        encryption?: {\n            /** lenght must be 16 characters */\n            secretKey: string;\n            /** @default true */\n            enabled?: boolean | undefined;\n        } | undefined;\n        templatingEngines?: {\n            /** @default 'dedicated-process' */\n            strategy?: EngineStrategy | undefined;\n            /**\n             * defines the number of worker processes used for generating reports\n             * @default 1\n             */\n            numberOfWorkers?: number | undefined;\n            forkOptions?: {\n                execArgv?: string | string[] | undefined;\n            } | undefined;\n            allowedModules?: string | string[] | undefined;\n            /** sets the reporter timeout in milliseconds */\n            timeout?: number | undefined;\n            templateCache?: {\n                max: number;\n                enabled: boolean;\n            } | undefined;\n        } | undefined;\n        store?: {\n            provider?: ReporterOptionsStoreProvider | undefined;\n        } | undefined;\n        blobStorge?: {\n            provider?: ReporterOptionsBlobStorageProvider | undefined;\n        } | undefined;\n        extensions?: any;\n        extensionsList?: string[] | undefined;\n        /** @default true */\n        migrateEntitySetsToFolders?: boolean | undefined;\n        connectionString?: string | undefined;\n    }\n\n    interface Settings {\n        add(key: string, value: any, req: Request): any;\n        get(key: string): [SettingItem];\n        findValue(key: string, req: Request): any;\n        set(key: string, avalue: any, req: Request): any;\n        addOrSet(key: string, avalue: any, req: Request): number | null;\n        init(documentStore: any, authorization: any): any;\n        _collection: SettingItem[];\n        documentStore: any;\n        registerEntity(documentStore: any): void;\n    }\n\n    interface SettingItem {\n        key: string;\n        value: any;\n    }\n\n    interface SchemaValidator {\n        schemaVersion: string;\n ",
  "7eca0aa421c535497e59aa231b955ea2b47712e4:types/jsreport-core/index.d.ts": "// Type definitions for jsreport-core 2.0\n// Project: http://jsreport.net\n// Definitions by: taoqf <https://github.com/taoqf>\n//                 pofider <https://github.com/pofider>\n//                 Keith Kikta <https://github.com/newbish>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n/// <reference types=\"node\" />\n\nimport * as fs from 'fs';\n\ndeclare namespace JsReport {\n    type Helpers = string | { [fun: string]: (...args: any[]) => any };\n\n    type Engine = \"none\";\n\n    type Recipe = \"html\";\n\n    interface TemplateBase {\n        /** template for the engine */\n        content?: string | undefined;\n        /** templating engine used to assemble document */\n        engine: Engine | string;\n        /** javascript helper functions used by templating engines */\n        helpers?: Helpers | undefined;\n        /** recipe used for printing previously assembled document */\n        recipe: Recipe | string;\n        pathToEngine?: string | undefined;\n    }\n\n    interface Template extends TemplateBase {\n        /** template for the engine */\n        content: string;\n    }\n\n    interface TemplateRegistry {\n        Template: Template;\n    }\n\n    type TemplateLike = TemplateRegistry[keyof TemplateRegistry]; // Template | NamedTemplate\n\n    interface RequestOptions {\n        preview?: boolean | undefined;\n        /** sets the request timeout in milliseconds */\n        timeout?: number | undefined;\n        /** defines the name of the report being to be generated */\n        reportName?: string | undefined;\n    }\n\n    interface Request {\n        /** @default true */\n        value?: boolean | undefined;\n        /** @default false */\n        writable?: boolean | undefined;\n        /** @default false */\n        configurable?: boolean | undefined;\n        /** @default false */\n        enumerable?: boolean | undefined;\n        /** defines the template of used for report generation */\n        template: TemplateLike;\n        /** defines options such as report name and request timeout */\n        options?: Partial<RequestOptions> | undefined;\n        context?: Context | undefined;\n        data?: any;\n    }\n\n    interface Context {\n        shared?: any;\n        originalInputDataIsEmpty?: boolean | undefined;\n        isChildRequest?: boolean | undefined;\n        logs: any;\n        timeoutLimit: number;\n    }\n\n    interface Response {\n        content: Buffer;\n        stream: NodeJS.ReadableStream;\n        headers: {\n            [header: string]: string | number | boolean;\n        };\n    }\n\n    interface ListenerCollection {\n        add(\n            type: string,\n            callback: (req: Request, res: Response, err?: any) => Promise<any> | void\n        ): void;\n    }\n\n    interface Collection {\n        find(query: { [field: string]: any }): Promise<object[]>;\n        update(query: { [field: string]: any }, update: object, options?: object): Promise<any>;\n        remove(query: { [field: string]: any }): Promise<any>;\n        insert(obj: object): Promise<object>;\n    }\n\n    interface DocumentStore {\n        collection(name: string): Collection;\n        registerEntityType(name:string, options:any): void;\n        registerEntitySet(name:string, options:any): void;\n    }\n\n    type Extension = (reporter: Reporter, definition: object) => void;\n\n    interface ExtensionDefinition {\n        options: any;\n        main: any;\n        directory: string;\n    }\n\n    interface ReporterInstance {\n        defaults?: Defaults | undefined;\n        options?: Configuration | undefined;\n        afterRenderListeners: ListenerCollection;\n        afterTemplatingEnginesExecutedListeners: ListenerCollection;\n        beforeRenderListeners: ListenerCollection;\n        closeListeners: ListenerCollection;\n        documentStore: DocumentStore;\n        blobStorage: BlobStorage;\n        initializeListeners: ListenerCollection;\n        renderErrorListeners: ListenerCollection;\n        // it would be nice to add winston.LoggerInstance here\n        // however adding import winston = require('winston') breaks exported enums\n        logger?: any;\n        validateRenderListeners: ListenerCollection;\n        version?: string | undefined;\n        settings: Settings;\n        optionsValidator: SchemaValidator;\n        entityTypeValidator: SchemaValidator;\n    }\n\n    interface Reporter extends ReporterInstance {\n        use(extension: Extension | ExtensionDefinition): Reporter;\n        init(): Promise<Reporter>;\n        render(request: Request, parent?: Request): Promise<Response>;\n        discover(): Reporter;\n        createListenerCollection(): ListenerCollection;\n        close(): Promise<void>;\n        extensionsLoad(opts: any): Promise<Reporter>;\n        checkValidEntityName(c: string, doc: any, req: Request): Promise<void>;\n        createError(message: string, options?: any): any;\n        getAvailableRenderTimeout(req: Request, defaultValue: number): number;\n        executeScript(inputs: any, options: any, req: Request): Promise<any>;\n        afterConfigLoaded(cb: () => void): Reporter;\n        addRequestContextMetaConfig(property: any, options: any): void;\n        getRequestContextMetaConfig(property: any): any;\n        addPathToWatchForAutoCleanup(customPath: string): void;\n        getPathsToWatchForAutoCleanup(): string[];\n        ensureTempDirectoryExists(): Promise<TempDirectoryResult>;\n        readTempFile(filename: string, opts: any): Promise<ReadTempFileResult>;\n        writeTempFile(filenameFn: () => string, content: any, opts: any): Promise<WriteFileResult>;\n        readTempFileStream(filename: string, opts: any): Promise<ReadTempFileStreamResult>;\n        writeTempFileStream(filenameFn: () => string, opts: any): Promise<WriteFileStreamResult>;\n        silentLogs(logger: any): void;\n    }\n\n    interface Defaults {\n        loadConfig?: boolean | undefined;\n        rootDirectory?: string | undefined;\n    }\n\n    type ReporterOptionsStoreProvider = 'memory';\n    type ReporterOptionsBlobStorageProvider = 'memory' | 'fs';\n    type EngineStrategy = 'dedicated-process' | 'http-server' | 'in-process';\n\n    interface Configuration {\n        mode?: any;\n        /** specifies where is the application root and where jsreport searches for extensions */\n        rootDirectory?: string | undefined;\n        /** specifies directory of the script that was used to start node.js, this value is mostly metadata that is useful for your own code inside jsreport scripts */\n        appDirectory?: string | undefined;\n        /**\n         * specifies where jsreport stores temporary files used by the conversion pipelineDef\n         * @default getDefaultTempDirectory()\n         */\n        tempDirectory?: string | undefined;\n        /**\n         * specifies if jsreport should load configuration values from external sources (cli args, env vars, configuration files) or not\n         * @default getDefaultLoadConfig()\n         */\n        loadConfig?: boolean | undefined;\n        /** specifies if after some interval jsreport should automatically clean up temporary files generated while rendering reports */\n        autoTempCleanup?: boolean | undefined;\n        /** specifies if jsreport should discover/search installed extensions in project and use them automatically */\n        discover?: boolean | undefined;\n        /**\n         * wheter if jsreport should read list of extensions from a previous generated cache or if it should crawl and try to search extensions again, set it to false when you want to always\n         * force crawling node_modules when searching for extensions while starting jsreport\n         * @default true\n         */\n        useExtensionsLocationCache?: boolean | undefined;\n        logger?: {\n            silent?: boolean | undefined;\n        } | undefined;\n        /** global single timeout that controls how much a report generation should wait before it times out */\n        reportTimeout?: number | undefined;\n        /**\n         * option that enables passing a custom report timeout per request using req.options.timeout. this enables that the caller of the report generation control the report timeout so enable it\n         * only when you trust the caller\n         * @default false\n         */\n        enableRequestReportTimeout?: boolean | undefined;\n        /** @default false */\n        allowLocalFilesAccess?: boolean | undefined;\n        encryption?: {\n            /** lenght must be 16 characters */\n            secretKey: string;\n            /** @default true */\n            enabled?: boolean | undefined;\n        } | undefined;\n        templatingEngines?: {\n            /** @default 'dedicated-process' */\n            strategy?: EngineStrategy | undefined;\n            /**\n             * defines the number of worker processes used for generating reports\n             * @default 1\n             */\n            numberOfWorkers?: number | undefined;\n            forkOptions?: {\n                execArgv?: string | string[] | undefined;\n            } | undefined;\n            allowedModules?: string | string[] | undefined;\n            /** sets the reporter timeout in milliseconds */\n            timeout?: number | undefined;\n            templateCache?: {\n                max: number;\n                enabled: boolean;\n            } | undefined;\n        } | undefined;\n        store?: {\n            provider?: ReporterOptionsStoreProvider | undefined;\n        } | undefined;\n        blobStorge?: {\n            provider?: ReporterOptionsBlobStorageProvider | undefined;\n        } | undefined;\n        extensions?: any;\n        extensionsList?: string[] | undefined;\n        /** @default true */\n        migrateEntitySetsToFolders?: boolean | undefined;\n        connectionString?: string | undefined;\n    }\n\n    interface Settings {\n        add(key: string, value: any, req: Request): any;\n        get(key: string): [SettingItem];\n        findValue(key: string, req: Request): any;\n        set(key: string, avalue: any, req: Request): any;\n        addOrSet(key: string, avalue: any, req: Request): number | null;\n        init(documentStore: any, authorization: any): any;\n        _collection: SettingItem[];\n        documentStore: any;\n        registerEntity(documentStore: any): void;\n    }\n\n    interface Setting"
}
